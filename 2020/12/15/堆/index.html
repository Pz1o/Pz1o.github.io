<!DOCTYPE html>


  <html class="dark page-post">


<head>
  <meta charset="utf-8">
  
  <title>堆 | pz1o</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="PWN,堆," />
  

  <meta name="description" content="堆(持续更新)https:&#x2F;&#x2F;ld1ng.com&#x2F;2020&#x2F;07&#x2F;23&#x2F;Heap&#x2F; https:&#x2F;&#x2F;ctf-wiki.github.io&#x2F;ctf-wiki&#x2F;pwn&#x2F;linux&#x2F;glibc-heap 上一个PWN学习 学得不太全面 写这个主要是为了自己能够全面复习堆的基础知识 由于我没学过操作系统 有些相关知识可能不太对 还请指正 基础0x01 什么是堆 在程序运行过程中，堆可以提供动态分配的内存，">
<meta property="og:type" content="article">
<meta property="og:title" content="堆">
<meta property="og:url" content="https://pz1o.top/2020/12/15/%E5%A0%86/index.html">
<meta property="og:site_name" content="pz1o">
<meta property="og:description" content="堆(持续更新)https:&#x2F;&#x2F;ld1ng.com&#x2F;2020&#x2F;07&#x2F;23&#x2F;Heap&#x2F; https:&#x2F;&#x2F;ctf-wiki.github.io&#x2F;ctf-wiki&#x2F;pwn&#x2F;linux&#x2F;glibc-heap 上一个PWN学习 学得不太全面 写这个主要是为了自己能够全面复习堆的基础知识 由于我没学过操作系统 有些相关知识可能不太对 还请指正 基础0x01 什么是堆 在程序运行过程中，堆可以提供动态分配的内存，">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201212002041969.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201212004040135.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201212004126045.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20201106174934849.jpg">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/2019072416485849.png">
<meta property="og:image" content="file://C:\Users\86138\Music\hexo\source\_posts\PWN学习\image-20201119163232880.png?lastModify=1607780072">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/201907300808254.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190730154304263.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190724174830502.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190722153928310.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/2019072217303470.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214183532647.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214183701946.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214183930779.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214221400402.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214221458119.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190724195005380.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214190713309.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214191149578.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214191901328.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201214191928725.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215160058074.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215160443811.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215160534048.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215160746395.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215161151487.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215161023500.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215161240081.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190729213257204.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190729212907497.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215163335296.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215163518823.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215163755383.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215164417439.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215165029835.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215170240262.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215194907019.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215194956787.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215195122071.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215195147425.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215200256907.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215200306820.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215200355918.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215200826010.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215201134939.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215201206634.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215201235306.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215201554898.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201215202105325.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190810155737453.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/20190810155901661.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216141039796.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216141113312.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216141143610.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216141159043.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216142837517.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216143203315.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216151435089.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216151556927.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216151633713.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216151705158.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216155717972.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216160152597.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216160410739.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216160827250.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216160910272.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216164710877.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216164747866.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216164913709.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216165109899.png">
<meta property="og:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201216165224983.png">
<meta property="article:published_time" content="2020-12-15T08:19:22.000Z">
<meta property="article:modified_time" content="2020-12-22T13:19:27.950Z">
<meta property="article:author" content="pz1o">
<meta property="article:tag" content="PWN">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pz1o.top/2020/12/15/%E5%A0%86/image-20201212002041969.png">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    
<link rel="stylesheet" href="/css/personal-style.css">

  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-38189205-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?e90b4c8b8c36ca2b3e5798ef67088f84";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

<meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="pz1o" type="application/atom+xml">
</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">MAP</span>
  

  <div class="post-header LEFT">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">MAP</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            Blog
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/tag/"
            rel="noopener noreferrer"
            target="_self"
            >
            Tag
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="ROUND_RECT"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            About
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">Posts List</strong>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#堆-持续更新"><span class="toc-text">堆(持续更新)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基础"><span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#0x01-什么是堆"><span class="toc-text">0x01 什么是堆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x02-如何分配堆和释放堆"><span class="toc-text">0x02 如何分配堆和释放堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-malloc函数"><span class="toc-text">1.malloc函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-free函数"><span class="toc-text">2.free函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x03-如何实现堆"><span class="toc-text">0x03 如何实现堆</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Arena"><span class="toc-text">1.Arena</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Arena的数量及管理"><span class="toc-text">Arena的数量及管理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-malloc-state"><span class="toc-text">2.malloc_state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-heap-info"><span class="toc-text">3.heap_info</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-malloc-chunk"><span class="toc-text">4.malloc_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#malloc-chunk的内存分配大小"><span class="toc-text">malloc_chunk的内存分配大小</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#mchunk-size的标记位的复用"><span class="toc-text">mchunk_size的标记位的复用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x04-chunk的分类"><span class="toc-text">0x04 chunk的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-allocated-chunk"><span class="toc-text">1.allocated chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-free-chunk"><span class="toc-text">2.free chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-top-chunk"><span class="toc-text">3.top chunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-last-remainder-chunk"><span class="toc-text">4.last remainder chunk</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x05-bins分类"><span class="toc-text">0x05 bins分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-bin的malloc-state"><span class="toc-text">1.bin的malloc_state</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-fastbin"><span class="toc-text">2.fastbin</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastbinsY数组存储fastbins的规则："><span class="toc-text">fastbinsY数组存储fastbins的规则：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-unsorted-bin"><span class="toc-text">3.unsorted bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-small-bin"><span class="toc-text">4.small bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-large-bin"><span class="toc-text">5.large bin</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Bin链表"><span class="toc-text">Large Bin链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x06-堆的调用流程"><span class="toc-text">0x06 堆的调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#当应用程序“第一次”使用malloc函数申请动态内存时，glibc库会向内核申请一块非常大的动态内存，这块动态内存会比malloc申请的大小大很多"><span class="toc-text">当应用程序“第一次”使用malloc函数申请动态内存时，glibc库会向内核申请一块非常大的动态内存，这块动态内存会比malloc申请的大小大很多</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x07-chunk的标志位"><span class="toc-text">0x07 chunk的标志位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-简介"><span class="toc-text">1.简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-实现"><span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-PREV-INUSE位导致的chunk合并"><span class="toc-text">3.PREV_INUSE位导致的chunk合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-fast-chunk的PREV-INUSE"><span class="toc-text">4.fast chunk的PREV_INUSE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-演示"><span class="toc-text">5.演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x08-chunk的mchunk-prev-size成员的空间复用"><span class="toc-text">0x08 chunk的mchunk_prev_size成员的空间复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-介绍"><span class="toc-text">1.介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-实现-1"><span class="toc-text">2.实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-演示"><span class="toc-text">3.演示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x09-chunk的大小"><span class="toc-text">0x09 chunk的大小</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-chunk的实际大小"><span class="toc-text">1.chunk的实际大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-chunk的最低大小"><span class="toc-text">2.chunk的最低大小</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x10-bins的单向链表、双向链表存储结构"><span class="toc-text">0x10 bins的单向链表、双向链表存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-fastbins的单向链表存储结构"><span class="toc-text">1.fastbins的单向链表存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-unsortedbin的双向链表存储结构"><span class="toc-text">2.unsortedbin的双向链表存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x11-top-chunk的向前合并"><span class="toc-text">0x11 top chunk的向前合并</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-top-chunk概念"><span class="toc-text">1.top chunk概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-top-chunk的合并操作"><span class="toc-text">2.top chunk的合并操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-演示-1"><span class="toc-text">3.演示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-如何防止top-chunk的合并"><span class="toc-text">4.如何防止top chunk的合并</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x12-chunk的malloc、free"><span class="toc-text">0x12 chunk的malloc、free</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-malloc的机制"><span class="toc-text">1.malloc的机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-演示"><span class="toc-text">2.演示</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#恰好分割一整块的free-chunk（fastbin）"><span class="toc-text">恰好分割一整块的free chunk（fastbin）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#切割一块chunk（fastbin）"><span class="toc-text">切割一块chunk（fastbin）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#恰好分割一整块的free-chunk（unsorted-bin）"><span class="toc-text">恰好分割一整块的free chunk（unsorted bin）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#切割一块chunk（unsorted-bin）"><span class="toc-text">切割一块chunk（unsorted bin）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-free的机制"><span class="toc-text">3.free的机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x13-malloc-consolidate"><span class="toc-text">0x13 malloc_consolidate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-consolidate的定义"><span class="toc-text">1.consolidate的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-触发场景"><span class="toc-text">2.触发场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-具体分析"><span class="toc-text">3.具体分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-演示一"><span class="toc-text">4.演示一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-演示二"><span class="toc-text">5.演示二</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0x14-last-remainder"><span class="toc-text">0x14 last remainder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-定义"><span class="toc-text">1.定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-产生场景"><span class="toc-text">2.产生场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-last-remainder的consolidate"><span class="toc-text">3.last remainder的consolidate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-演示一-1"><span class="toc-text">4.演示一</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-演示二-1"><span class="toc-text">5.演示二</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-演示三"><span class="toc-text">6.演示三</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-演示四"><span class="toc-text">7.演示四</span></a></li></ol></li></ol></li></ol></li></ol>
  </div>



<div class="content content-post LEFT">
   <article id="post-堆" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">堆</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2020.12.15</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>pz1o</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/PWN/">PWN</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <h1 id="堆-持续更新"><a href="#堆-持续更新" class="headerlink" title="堆(持续更新)"></a>堆(持续更新)</h1><p><a href="https://ld1ng.com/2020/07/23/Heap/" target="_blank" rel="noopener">https://ld1ng.com/2020/07/23/Heap/</a></p>
<p><a href="https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap" target="_blank" rel="noopener">https://ctf-wiki.github.io/ctf-wiki/pwn/linux/glibc-heap</a></p>
<p>上一个PWN学习 学得不太全面</p>
<p>写这个主要是为了自己能够全面复习堆的基础知识</p>
<p>由于我没学过操作系统 有些相关知识可能不太对 还请指正</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="0x01-什么是堆"><a href="#0x01-什么是堆" class="headerlink" title="0x01 什么是堆"></a>0x01 什么是堆</h3><ul>
<li>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存</li>
<li>堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长</li>
<li>我们一般成管理堆的那部分程序为堆管理器</li>
</ul>
<p>堆管理器处于用户程序与内核中间，主要做以下工作</p>
<ul>
<li>malloc</li>
<li>free</li>
</ul>
<h3 id="0x02-如何分配堆和释放堆"><a href="#0x02-如何分配堆和释放堆" class="headerlink" title="0x02 如何分配堆和释放堆"></a>0x02 如何分配堆和释放堆</h3><h4 id="1-malloc函数"><a href="#1-malloc函数" class="headerlink" title="1.malloc函数"></a>1.<strong>malloc函数</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数返回对应大小字节的内存块的指针</li>
<li>此外，该函数还对一些异常情况进行了处理</li>
<li>当n=0时，返回当前系统允许的堆的最小内存块</li>
<li><strong>当n为负数时，由于在大多数系统中，size_t是无符号数，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配</strong></li>
</ul>
<h4 id="2-free函数"><a href="#2-free函数" class="headerlink" title="2.free函数"></a>2.<strong>free函数</strong></h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *p)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>该函数会释放由p所指向的内存块。这个内存块有可能是通过malloc函数得到的，也有可能是通过相关的函数realloc得到的</li>
</ul>
<p>该函数还对异常情况进行了一下处理</p>
<ul>
<li>当p为空指针时，函数不执行任何操作</li>
<li>当p已经被释放之后，再次释放会出现错误的效果，这其实就是double free</li>
<li>除了被禁用（mallocpt）的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便减小程序所使用的内存空间</li>
</ul>
<h3 id="0x03-如何实现堆"><a href="#0x03-如何实现堆" class="headerlink" title="0x03 如何实现堆"></a>0x03 如何实现堆</h3><ul>
<li>堆的glibc实现主要包括struct _heap_info，struct malloc_state，struct malloc_chunk这3个结构体</li>
</ul>
<h4 id="1-Arena"><a href="#1-Arena" class="headerlink" title="1.Arena"></a>1.Arena</h4><p><img src="/2020/12/15/%E5%A0%86/image-20201212002041969.png" alt="image-20201212002041969"></p>
<blockquote>
<ul>
<li>一个线程只有一个arnea，并且这些线程的arnea都是独立的不是相同的</li>
<li>主线程的arnea称为“main_arena”。子线程的arnea称为“thread_arena”</li>
</ul>
</blockquote>
<h5 id="Arena的数量及管理"><a href="#Arena的数量及管理" class="headerlink" title="Arena的数量及管理"></a>Arena的数量及管理</h5><p>我们说到有主线程和子线程的arena</p>
<p><strong>那么每个程序的arena的数量应该就是有限的</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">32</span>位系统中：</span><br><span class="line">     Number of arena = <span class="number">2</span> * number of cores + <span class="number">1.</span></span><br><span class="line"><span class="number">64</span>位系统中：</span><br><span class="line">     Number of arena = <span class="number">8</span> * number of cores + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>这里就会涉及一个多线程共享问题</p>
<blockquote>
<p>eg：一个主Arena 两个副Arena</p>
<p>如果有一个4线程（大于3个Arena）的程序，显然这里就会出现一个共享问题</p>
<p><strong>此时glibc malloc会做以下操作：</strong></p>
<ul>
<li>首先，glibc malloc循环遍历所有可用的竞技场，在遍历的过程中，它会尝试锁该竞技场。如果成功锁（该竞技场当前对应的线程并未使用堆内存则表示可锁），那么该竞技场就可以被线程3所使用</li>
<li>而如果没能找到可用的舞台上，那么就将线程3的malloc的操作阻塞，直到有可用的舞台为止</li>
<li>当线程3的malloc阻塞解除时，glibc malloc就会先尝试使用最近访问的竞技场（此时为主竞技场）。如果此时主竞技场可用的话，就直接使用，否则就将线程3再次阻塞，直到主舞台上再次可用为止</li>
</ul>
</blockquote>
<h4 id="2-malloc-state"><a href="#2-malloc-state" class="headerlink" title="2.malloc_state"></a>2.<strong>malloc_state</strong></h4><ul>
<li>glibc的中arnea就是用这个结构体表示的</li>
<li>其中包含很多的信息：各种bins的信息，top chunk以及最后一个剩余chunk等</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  __libc_lock_define (, mutex);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class="line">  <span class="comment">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class="line">  <span class="keyword">int</span> have_fastchunks;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>fastbinsY数组：</strong>存储的是该领域管理的fastbins</li>
<li><strong>bins数组：</strong>存储的是该领域管理的smallbins，unsortedbin，largebin</li>
<li><strong>binmap变量：</strong>系统查看有哪些垃圾箱链中有块时，不可能去fastbinsY和箱数组一个一个的遍历通过binmap变量，采用二进制存储，将二进制位与数组的索引相对，系统查找箱链时可以。通过按位与来查询，这样更高效。虽然unsigned int的二进制位比数组总元素少，但是系统不会有那么多的bin链，不需要考虑这个问题</li>
</ul>
</blockquote>
<h4 id="3-heap-info"><a href="#3-heap-info" class="headerlink" title="3.heap_info"></a>3.<strong>heap_info</strong></h4><ul>
<li>我们知道一个线程可以包含多个堆段，这些堆段同属于一个舞台来管理。每个堆段的信息就是用这个结构体来表示的</li>
<li><strong>注意：</strong>这个不是存储堆块的数据，而是来解释说明这个堆段的</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  mstate ar_ptr;            <span class="comment">/* Arena for this heap. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span>  <span class="comment">/* Previous heap. */</span></span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span>;              <span class="comment">/* Current size in bytes. */</span></span><br><span class="line">  <span class="keyword">size_t</span> mprotect_size;     <span class="comment">/* Size in bytes that has been mprotected</span></span><br><span class="line"><span class="comment">                             PROT_READ|PROT_WRITE.  */</span></span><br><span class="line">  <span class="comment">/* Make sure the following data is properly aligned, particularly</span></span><br><span class="line"><span class="comment">     that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of</span></span><br><span class="line"><span class="comment">     MALLOC_ALIGNMENT. */</span></span><br><span class="line">  <span class="keyword">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK];</span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>ar_ptr：</strong>此堆段归属于哪一个arnea管理</li>
<li><strong>prev：</strong>前一个堆段</li>
</ul>
</blockquote>
<h4 id="4-malloc-chunk"><a href="#4-malloc-chunk" class="headerlink" title="4.malloc_chunk"></a>4.malloc_chunk</h4><ul>
<li>一个堆块被分为多个块，这些块就是用这些结构体表示的，这个才是我们在glibc的正真存储堆数据信息的结构体</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"> </span><br><span class="line">  INTERNAL_SIZE_T      mchunk_prev_size;  <span class="comment">/* Size of previous chunk (if free).*/</span></span><br><span class="line">  INTERNAL_SIZE_T      mchunk_size;       <span class="comment">/* Size in bytes, including overhead.*/</span></span><br><span class="line"> </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>   <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><p>每个成员都是8字节（64位系统中），4字节（32位系统中）</p>
</li>
<li><p><strong>mchunk_prev_size：</strong>只有当该chunk的物理相邻的前一地址chunk是空闲的话，该字段在本chunk中才有用，用来记录前一个chunk 的大小 (包括chunk头)。否则，该字段为0是没有用的；但是当前一个chunk申请的大小大于前一个chunk的大小时，那么该字段可以用来给前一个chunk使用（这就是chunk的空间复用，后面文章介绍）</p>
</li>
<li><strong>mchunk_size：</strong>当前chunk的大小，chunk大小都是8字节对齐</li>
</ul>
</blockquote>
<p>这里我们来看一下gdb调试的界面</p>
<p>源码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        p = <span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *H;</span><br><span class="line">    H = <span class="built_in">malloc</span>(<span class="number">64</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(H,<span class="string">"aaaaaaaaaaaaaaaa"</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">free</span>(H);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">gcc -o a.out a.c#<span class="number">64</span>位</span><br><span class="line">gcc -m32 -o b.out b.c#<span class="number">32</span>位</span><br></pre></td></tr></table></figure>
<p>64位</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201212004040135.png" alt="image-20201212004040135"></p>
<p>32位</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201212004126045.png" alt="image-20201212004126045"></p>
<blockquote>
<p><strong>当前chunk处于分配状态时：</strong></p>
<ul>
<li>fd：从fd字段开始的是用户的数据</li>
</ul>
<p><strong>当前chunk处于空闲时：</strong></p>
<p>因为chunk处于空闲时，会被放到bin链中，所以fd和bk用于指向自己所在bin链中前后的空闲chunk</p>
<ul>
<li>fd：指向前一个（非物理相邻）空闲的 chunk的指针（头指针）</li>
<li>bk：指向后一个（非物理相邻）空闲的 chunk的指针</li>
<li>通过fd和bk可以将空闲的chunk块加入到空闲的chunk块链表进行统一管理</li>
</ul>
<p><strong>fd_nextsize、bk_nextsize</strong></p>
<p>也是只有chunk空闲的时候才使用，不过其用于较大的chunk（large chunk）</p>
<ul>
<li>fd_nextsize：指向前一个与当前 chunk 大小不同的第一个空闲块，不包含bin的头指针</li>
<li>bk_nextsize：指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针</li>
</ul>
<p>一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历</p>
</blockquote>
<h5 id="malloc-chunk的内存分配大小"><a href="#malloc-chunk的内存分配大小" class="headerlink" title="malloc_chunk的内存分配大小"></a>malloc_chunk的内存分配大小</h5><p><strong>最小的空间：</strong>mchunk_prev_size字段 + mchunk_size字段 + fd字段 + bk字段 所需要的空间。所以64位系统最低需要 4 * SIZE_SZ = 32字节；32位系统是16字节</p>
<p><strong>实际空间：</strong>malloc大小 + chunk对齐规则 + mchunk_prev_size字段 + mchunk_size字段 + 下一个chunk的mchunk_prev_size成员空间</p>
<p>chunk的数据结构大小的图（64位系统）</p>
<p><img src="/2020/12/15/%E5%A0%86/20201106174934849.jpg" alt="img"></p>
<h5 id="mchunk-size的标记位的复用"><a href="#mchunk-size的标记位的复用" class="headerlink" title="mchunk_size的标记位的复用"></a>mchunk_size的标记位的复用</h5><p>mchunk_size在64位系统下是8个字节，字段的最后三个bit位，复用用作了（AMP）的标记位置。后三位bit位的复用，不会影响size的数据大小</p>
<ul>
<li>A：A=0 为主分区分配，A=1 为非主分区分配，参见后面</li>
<li>M：M=1表示使用mmap映射区域，M=0为使用heap区域</li>
<li>P：P=0 表示pre_chunk空闲，mchunk_prev_size才有效</li>
</ul>
<h3 id="0x04-chunk的分类"><a href="#0x04-chunk的分类" class="headerlink" title="0x04 chunk的分类"></a>0x04 chunk的分类</h3><h4 id="1-allocated-chunk"><a href="#1-allocated-chunk" class="headerlink" title="1.allocated chunk"></a>1.allocated chunk</h4><p>当前chunk是被应用层用户所使用的</p>
<h4 id="2-free-chunk"><a href="#2-free-chunk" class="headerlink" title="2.free chunk"></a>2.free chunk</h4><p>当前chunk是空闲的，没有被应用层用户所使用</p>
<h4 id="3-top-chunk"><a href="#3-top-chunk" class="headerlink" title="3.top chunk"></a>3.<strong>top chunk</strong></h4><ul>
<li><strong>概念：</strong>当一个chunk处于一个arena的最顶部(即最高内存地址处)的时候，就称之为top chunk</li>
<li><strong>作用：</strong>该chunk并<strong>不属于任何</strong>bin，而是在系统当前的所有free chunk(无论那种bin)都无法满足用户请求的内存大小的时候，将此chunk当做一个应急消防员，分配给用户使用</li>
<li><strong>分配的规则：</strong>如果top chunk的大小比用户请求的大小要大的话，就将该top chunk分作两部分：1）用户请求的chunk；2）剩余的部分成为新的top chunk。否则，就需要扩展heap或分配新的heap了——在main arena中通过sbrk扩展heap，而在thread arena中通过mmap分配新的heap</li>
</ul>
<h4 id="4-last-remainder-chunk"><a href="#4-last-remainder-chunk" class="headerlink" title="4.last remainder chunk"></a>4.last remainder chunk</h4><ul>
<li><strong>它是怎么产生的：</strong>当用户请求的是一个small chunk，且该请求无法被small bin、unsorted bin满足的时候，就通过binmaps遍历bin查找最合适的chunk，如果该chunk有剩余部分的话，就将该剩余部分变成一个新的chunk加入到unsorted bin中，另外，<strong>再将该新的chunk变成新的last remainder chunk</strong></li>
<li><strong>它的作用是什么：</strong>此类型的chunk用于提高连续malloc(small chunk)的效率，主要是提高内存分配的局部性。那么具体是怎么提高局部性的呢？举例说明。当用户请求一个small chunk，且该请求无法被small bin满足，那么就转而交由unsorted bin处理。同时，假设当前unsorted bin中只有一个chunk的话——就是last remainder chunk，那么就将该chunk分成两部分：前者分配给用户，剩下的部分放到unsorted bin中，并成为新的last remainder chunk。这样就保证了连续malloc(small chunk)中，各个small chunk在内存分布中是相邻的，即提高了内存分配的局部性</li>
</ul>
<h3 id="0x05-bins分类"><a href="#0x05-bins分类" class="headerlink" title="0x05 bins分类"></a>0x05 bins分类</h3><blockquote>
<ul>
<li>bin是一个由struct chunk结构体组成的链表</li>
<li>前面介绍过，不同的chunk根据特点不同分为不同的chunk，为了将这些chunk进行分类的管理，glibc采用了bin链这种方式管理不同的chunk</li>
<li>不同的bin链是由arena管理的</li>
<li>bin链中的chunk均为free chunk</li>
</ul>
</blockquote>
<h4 id="1-bin的malloc-state"><a href="#1-bin的malloc-state" class="headerlink" title="1.bin的malloc_state"></a>1.bin的malloc_state</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"> </span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">/*other member*/</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>fastbinY数组：</strong>大小为10。记录的是fast bin链</li>
<li><strong>bins数组：</strong>大小为129。记录的是unsorted bin（1）、small bin（2~63）、large bin链（64~126）</li>
</ul>
<h4 id="2-fastbin"><a href="#2-fastbin" class="headerlink" title="2.fastbin"></a>2.fastbin</h4><p><strong>概念：</strong>chunk的大小在32字节到128字节（0x20~0x80）的chunk称为“fast chunk（大小不是malloc时的大小，而是在内存中struct malloc_chunk的大小，包含前2个成员）</p>
<ul>
<li>fast bin链表的个数为10个</li>
<li><strong>不会对free chunk进行合并：</strong>鉴于设计fast bin的初衷就是进行快速的小内存分配和释放，因此系统将属于<strong>fast bin的chunk的PREV_INUSE位总是设置为1</strong>，这样即使当fast bin中有某个chunk同一个free chunk相邻的时候，系统也不会进行自动合并操作，而是保留两者。虽然这样做可能会造成额外的碎片化问题，但瑕不掩瑜</li>
<li>LIFO</li>
</ul>
<blockquote>
<h3 id="fastbinsY数组存储fastbins的规则："><a href="#fastbinsY数组存储fastbins的规则：" class="headerlink" title="fastbinsY数组存储fastbins的规则："></a>fastbinsY数组存储fastbins的规则：</h3><ul>
<li>每个fast bin链表都是单链表（使用fd指针）。因此，fast bin中无论是添加还是移除fast chunk，都是对“链表尾”进行操作，而不会对某个中间的fast chunk进行操作</li>
<li>单个fastbin链表中的chunk大小都是相同的，各个fastbin链表中的chunk大小是不同的</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/2019072416485849.png" alt="img"></p>
</blockquote>
<h4 id="3-unsorted-bin"><a href="#3-unsorted-bin" class="headerlink" title="3.unsorted bin"></a>3.unsorted bin</h4><p>当释放较小或较大的chunk的时候，如果系统没有将它们添加到对应的bins中，系统就将这些chunk添加到unsorted bin中。在堆管理器的unsorted bin 不为空时，<strong>用户申请非fast bin大小的内存</strong>会先从unsorted bin中查找，如果找到符合该申请大小要求的chunk，则直接分配或分割该chunk。</p>
<ul>
<li>unsorted bin的个数： 1个</li>
<li>unsorted bin是一个由free chunks组成的循环双链表</li>
<li>在unsorted bin中，对chunk的大小并没有限制，任何大小的chunk都可以归属到unsorted bin中</li>
<li>unsortedbin采用的遍历顺序是FIFO</li>
</ul>
<p><img src="file://C:\Users\86138\Music\hexo\source\_posts\PWN学习\image-20201119163232880.png?lastModify=1607780072" alt="image-20201119163232880"></p>
<h4 id="4-small-bin"><a href="#4-small-bin" class="headerlink" title="4.small bin"></a>4.small bin</h4><p><strong>概念</strong>：小于1024字节（0x400）的chunk称之为small chunk，small bin就是用于管理small chunk的</p>
<ul>
<li>small bin链表的个数为62个</li>
<li>FIFO</li>
<li><strong>循环双向链表</strong>，就内存的分配和释放速度而言，small bin比larger bin快，但比fast bin慢</li>
</ul>
<blockquote>
<p><strong>Small bin链表</strong></p>
<ul>
<li>每个smallbin也是一个由对应free chunk组成的循环双链表</li>
<li><strong>small bin采用FIFO(先入先出)算法：</strong>内存释放操作就将新释放的chunk添加到链表的front end(前端)，分配操作就从链表的rear end(尾端)中获取chunk</li>
<li>单个smallbin链表中的chunk大小都是相同的，各个smallbin链表中的chunk大小是不同的，跟fastbinsY数组存储fastbin链的原理是相同的</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/201907300808254.png" alt="img"></p>
</blockquote>
<h4 id="5-large-bin"><a href="#5-large-bin" class="headerlink" title="5.large bin"></a>5.large bin</h4><p><strong>概念：</strong>大于等于1024字节（0x400）的chunk称之为large chunk，large bin就是用于管理这些largechunk的</p>
<ul>
<li>large bin链表的个数为63个，被分为6组</li>
<li>largechunk使用fd_nextsize、bk_nextsize连接起来的</li>
</ul>
<blockquote>
<h3 id="Large-Bin链表"><a href="#Large-Bin链表" class="headerlink" title="Large Bin链表"></a>Large Bin链表</h3><ul>
<li>同一个largebin中每个chunk的大小可以不一样，这些chunk根据一定的范围存储在一个larbin链表中</li>
<li>large chunk可以添加、删除在large bin的任何一个位置</li>
<li><strong>在这63个largebins中：</strong>第一组的32个largebin链<strong>依次以64字节步长为间隔，即第一个largebin链中chunksize为1024-1087字节，第二个large bin中chunk size为1088~1151字节。</strong>第二组的16个largebin链<strong>依次以512字节步长为间隔；</strong>第三组的8个largebin链<strong>以步长4096为间隔；</strong>第四组的4个largebin链<strong>以32768字节为间隔；</strong>第五组的2个largebin链<strong>以262144字节为间隔；</strong>最后一组**的largebin链中的chunk大小无限制</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/20190730154304263.png" alt="img"></p>
</blockquote>
<p><img src="/2020/12/15/%E5%A0%86/20190724174830502.png" alt="img"></p>
<h3 id="0x06-堆的调用流程"><a href="#0x06-堆的调用流程" class="headerlink" title="0x06 堆的调用流程"></a>0x06 堆的调用流程</h3><p><img src="/2020/12/15/%E5%A0%86/20190722153928310.png" alt="img"></p>
<ul>
<li><h4 id="当应用程序“第一次”使用malloc函数申请动态内存时，glibc库会向内核申请一块非常大的动态内存，这块动态内存会比malloc申请的大小大很多"><a href="#当应用程序“第一次”使用malloc函数申请动态内存时，glibc库会向内核申请一块非常大的动态内存，这块动态内存会比malloc申请的大小大很多" class="headerlink" title="当应用程序“第一次”使用malloc函数申请动态内存时，glibc库会向内核申请一块非常大的动态内存，这块动态内存会比malloc申请的大小大很多"></a>当应用程序<strong>“第一次”</strong>使用malloc函数申请动态内存时，glibc库会向内核申请一块非常大的动态内存，这块动态内存会比malloc申请的大小大很多</h4></li>
<li><p>glibc申请到这块大的内存之后，根据malloc需要的大小，然后切割相应的大小给应用程序malloc函数使用</p>
</li>
<li><p>当应用层free之后，会将刚才使用到的动态内存返回给glibc，但是返回的内存不是返回给top chunk，而是由bins链管理</p>
</li>
<li><p>当程序再次malloc时，会从刚才申请的很大的动态内存去取，不会再去向内核申请内存</p>
</li>
<li><p>只有当第一次申请的动态内存使用完时，glibc才会再次通过brk/mmap系统调用向内核去要内存</p>
</li>
</ul>
<h3 id="0x07-chunk的标志位"><a href="#0x07-chunk的标志位" class="headerlink" title="0x07 chunk的标志位"></a>0x07 chunk的标志位</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h4><ul>
<li><strong>NON_MAIN_ARENA：</strong>记录当前 chunk 是否不属于主线程</li>
<li><strong>IS_MAPPED：</strong>记录当前chunk是否是由mmap分配的</li>
<li><strong>PREV_INUSE：</strong>如果前面一个chunk处于分配状态，那么此位为1。一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。当一个chunk 的size 的P位为0时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲chunk之间的合并</li>
</ul>
<h4 id="2-实现"><a href="#2-实现" class="headerlink" title="2.实现"></a>2.实现</h4><ul>
<li><strong>在64位系统中为16字节对齐</strong>，<strong>在32位的系统中为8字节对齐</strong>。因此在64位系统中，struct malloc_chunk结构体的大小的最后4个位数是没有被使用的，32位系统中，最后3个位数是没有被使用的。</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/2019072217303470.png" alt="img"></p>
<ul>
<li>所以，glibc用struct malloc_chunk结构体的fd成员的最后3个比特位来表示当前chunk处于什么状态。只需要将fd成员相应的比特位置为1，就可以代表当前chunk处于什么状态</li>
</ul>
<h4 id="3-PREV-INUSE位导致的chunk合并"><a href="#3-PREV-INUSE位导致的chunk合并" class="headerlink" title="3.PREV_INUSE位导致的chunk合并"></a>3.PREV_INUSE位导致的chunk合并</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">        prevsize = prev_size (p);                   <span class="comment">//1</span></span><br><span class="line">        <span class="built_in">size</span> += prevsize;                           <span class="comment">//2</span></span><br><span class="line">        p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize)); <span class="comment">//3</span></span><br><span class="line">        unlink(av, p, bck, fwd);                    <span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先使用prev_inuse宏定义判断p的PREV_INUSE位是否为0</li>
<li>如果PREV_INUSE位为0，那么prev_inuse宏返回0，if条件为1，进入if语句体中</li>
<li>1.通过recv_size函数得到前面要合并的chunk的大小</li>
<li>2.将自己的大小与前面的presize相加得到合并后的chunk的大小</li>
<li>3.将p的指针向前移动，移动到前面那个chunk的开头处</li>
<li>4.unlink是将两个要合并的chunk各自从原来的bin链上面断下来，然后进行合并</li>
</ul>
<h4 id="4-fast-chunk的PREV-INUSE"><a href="#4-fast-chunk的PREV-INUSE" class="headerlink" title="4.fast chunk的PREV_INUSE"></a>4.fast chunk的PREV_INUSE</h4><ul>
<li>①无论fastchunk前面的chunk是否处于分配状态，PREV_INUSE始终为1。因为系统不希望fastchunk与前面的chunk之间进行合并</li>
<li>②不论当前的fastchunk是否处于分配状态，该chunk后面的chunk的PREV_INUSE位一定为1，也是为了防止后面的chunk与fastchunk合并</li>
</ul>
<h4 id="5-演示"><a href="#5-演示" class="headerlink" title="5.演示"></a>5.演示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x70</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p3=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//为了达到演示效果，防止合并后的chunk与top chunk合并</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line">    <span class="built_in">free</span>(p1);    </span><br><span class="line">    <span class="built_in">free</span>(p2);   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到正好分配了3块</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214183532647.png" alt="image-20201214183532647"></p>
<p>看一下内存地址</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214183701946.png" alt="image-20201214183701946"></p>
<p>当我们释放一个之后</p>
<p>这里版本较高  淦 我先去找个虚拟机</p>
<p>可以看到是加到tcache中</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214183930779.png" alt="image-20201214183930779"></p>
<hr>
<p>弄了一晚上 我又回来了</p>
<p>释放第一个</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214221400402.png" alt="image-20201214221400402"></p>
<p>释放两个</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214221458119.png" alt="image-20201214221458119"></p>
<h3 id="0x08-chunk的mchunk-prev-size成员的空间复用"><a href="#0x08-chunk的mchunk-prev-size成员的空间复用" class="headerlink" title="0x08 chunk的mchunk_prev_size成员的空间复用"></a>0x08 chunk的mchunk_prev_size成员的空间复用</h3><h4 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h4><ul>
<li>①如果本chunk前面一个chunk处于空闲状态，那么mchunk_prev_size成员才有用，此时用来记录前一个chunk的大小</li>
<li>②如果本chunk前面一个chunk处于使用状态，那么mchunk_prev_size成员对于本chunk来说是不使用的</li>
</ul>
<h4 id="2-实现-1"><a href="#2-实现-1" class="headerlink" title="2.实现"></a>2.实现</h4><ul>
<li>当前一个chunk申请的数据空间申请的大小对16取余后，如果多出来的大小小于等于8字节，那么这个多出来的大小就放入下一个chunk的mchunk_prev_size中存储</li>
<li>否则，如果多出来的大小大于8字节，那么前一个chunk就不使用下一个chunk的mchunk_prev_size成员</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/20190724195005380.png" alt="img"></p>
<h4 id="3-演示"><a href="#3-演示" class="headerlink" title="3.演示"></a>3.演示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x108</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0x108模0x10之后还有8 说明是占用了下一个chunk的pre_size</p>
<p>64位16字节对齐 0x100(分配)+0x10(头)+0x1(P)</p>
</blockquote>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214190713309.png" alt="image-20201214190713309"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x109</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>0x109模0x10为9 所以pre_size不够用 需要多申请1个单元</p>
<p>chunk被隐式对齐位0x110</p>
<p>64位16字节对齐 0x110+0x10+0x1</p>
</blockquote>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214191149578.png" alt="image-20201214191149578"></p>
<h3 id="0x09-chunk的大小"><a href="#0x09-chunk的大小" class="headerlink" title="0x09 chunk的大小"></a>0x09 chunk的大小</h3><p>其实上一节我们就演示了 但这一节还是重点讲一下</p>
<h4 id="1-chunk的实际大小"><a href="#1-chunk的实际大小" class="headerlink" title="1.chunk的实际大小"></a>1.chunk的实际大小</h4><ul>
<li>当用户通过malloc函数申请堆内存时，可以使用的内存的起始地址是从fd成员开始的，所以用户无法访问结构体的前两个成员</li>
<li>当用户申请size大小的堆块时，在glibc中本质上是申请了size+16大小（64位系统中）的内存，因为要加上前两个成员</li>
<li>例如：malloc(0x10);申请了0x10大小的堆内存，本质上在glibc中申请了0x10+0x10=0x20大小的空间</li>
<li><strong>chunk的实际大小=malloc的大小+chunk的前两个成员+mchunk_prev_size成员的合并操作+chunk对齐规则</strong></li>
</ul>
<p>这个上面演示过了 就不演示了</p>
<h4 id="2-chunk的最低大小"><a href="#2-chunk的最低大小" class="headerlink" title="2.chunk的最低大小"></a>2.chunk的最低大小</h4><ul>
<li>malloc的堆块大小在glibc中会加上前两个成员的大小（0x10大小），所以当你分配一个堆内存时，堆内存的最小大小一定为0x20（0x10+0x10）。（即使malloc没有指定大小，也要分配fd和bk成员，所以加起来就是malloc_chunk结构体的前4个成员的大小总和）</li>
<li><strong>chunk的最低大小一定为0x20大小</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//int size=0x109;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他用处</span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(p1);    </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214191901328.png" alt="image-20201214191901328"></p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201214191928725.png" alt="image-20201214191928725"></p>
<h3 id="0x10-bins的单向链表、双向链表存储结构"><a href="#0x10-bins的单向链表、双向链表存储结构" class="headerlink" title="0x10 bins的单向链表、双向链表存储结构"></a>0x10 bins的单向链表、双向链表存储结构</h3><h4 id="1-fastbins的单向链表存储结构"><a href="#1-fastbins的单向链表存储结构" class="headerlink" title="1.fastbins的单向链表存储结构"></a>1.fastbins的单向链表存储结构</h4><ul>
<li>fastbins是单向链表存储，fastbins中的的chunk是不会合并的（glibc规定这些chunk的PREV_INUSE位永远为1）</li>
</ul>
<blockquote>
<p><strong>存储结构：</strong></p>
<ul>
<li><strong>fastbins的存储采用后进先出（LIFO）的原则：</strong>后free的chunk会被添加到先free的chunk的后面；同理，通过malloc取出chunk时是先去取最新放进去的</li>
<li>因为是单链表，fastbins中的所有chunk的bk是没有用到的</li>
<li>并且fastbins比较特殊，一个fastbin链第一个chunk指向于一个特殊的“0”，然后后面接的是后free的chunk……以此类推，最后一个chunk再由arena的malloc_state的fastbinsY数组所管理</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215160058074.png" alt="image-20201215160058074"></p>
</blockquote>
<p><strong>演示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x10</span>;</span><br><span class="line">    <span class="keyword">int</span> size2=<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span> *p3=<span class="built_in">malloc</span>(size2);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了程序打断点，没有其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打到断点处 heap的信息</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215160443811.png" alt="image-20201215160443811"></p>
<p>释放p1 p2</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215160534048.png" alt="image-20201215160534048"></p>
<p>可以看到第一个被释放chunk的fd指针指向0 而第二个被释放chunk的fd指针指向第一个</p>
<p>看一下main_arena 可以看到是指向最后一个chunk 也就验证了上面的结论</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215160746395.png" alt="image-20201215160746395"></p>
<p>接下来我们释放第三个</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215161151487.png" alt="image-20201215161151487"></p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215161023500.png" alt="image-20201215161023500"></p>
<p>由于与前两个大小不同所以我们会新开一个链表 说明main_arena的地址也不一样</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215161240081.png" alt="image-20201215161240081"></p>
<p>此次演示也就完成了</p>
<p>32位可自行演示</p>
</blockquote>
<h4 id="2-unsortedbin的双向链表存储结构"><a href="#2-unsortedbin的双向链表存储结构" class="headerlink" title="2.unsortedbin的双向链表存储结构"></a>2.unsortedbin的双向链表存储结构</h4><ul>
<li>free的chunk大小如果大于0x80会放到unsortedbin上</li>
<li>unsortedbin存储这些chunk是使用双向循环链表进行存储的（<strong>smallbins、largebins也是如此，此处只介绍unsortedbin</strong>）</li>
</ul>
<blockquote>
<p><strong>存储结构</strong>：</p>
<ul>
<li><strong>存储循环先入先出（FIFO）原则：</strong>上面的是先free掉的chunk，下面是后free掉的chunk；同理，通过malloc取出chunk时是先取上面的，再取下面的</li>
<li><strong>一个bins中只有一个freechunk时：</strong>就是下面这种表示形式。可以看到freechunk的fd和bk都指向于bins的fd，所以我们使用gdb调试时可以用命令看到，当bin链中只有一个freechunk时，其fd和bk都是相同的，都指向于bins的fd</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/20190729213257204.png" alt="img"></p>
<ul>
<li><strong>一个bins中有多个freechunk时：</strong>上面使我们的struct malloc_state结构体，结构体中的bins数组存储的就是这些bin链，下面就是bins数组中存储unsortedbin的位置，这个数组元素存储的其实就是一个fd和一个bk指针。下面第一个就是第一个free掉的chunk，再下面一个就是第二个free掉的chunk……以此类推</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/20190729212907497.png" alt="img"></p>
</blockquote>
<p><strong>演示</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x100</span>;</span><br><span class="line">    <span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//防止p1与p2合并</span></span><br><span class="line">    <span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);   </span><br><span class="line">    <span class="keyword">int</span> *p3=<span class="built_in">malloc</span>(<span class="built_in">size</span>);   <span class="comment">//防止p2被top chunk合并</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打断点</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215163335296.png" alt="image-20201215163335296"></p>
<p>释放p1</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215163518823.png" alt="image-20201215163518823"></p>
<p>从上面我们也可以看到下一个chunk的标志p位为0了</p>
<p>看下main_arena</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215163755383.png" alt="image-20201215163755383"></p>
<p>释放p2</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215164417439.png" alt="image-20201215164417439"></p>
<p>可以看到main_arena是变了的</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215165029835.png" alt="image-20201215165029835"></p>
<p>bins头中fd-&gt;p2 bk-&gt;p1</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215170240262.png" alt="image-20201215170240262"> </p>
<p>演示完成</p>
</blockquote>
<h3 id="0x11-top-chunk的向前合并"><a href="#0x11-top-chunk的向前合并" class="headerlink" title="0x11 top chunk的向前合并"></a>0x11 top chunk的向前合并</h3><h4 id="1-top-chunk概念"><a href="#1-top-chunk概念" class="headerlink" title="1.top chunk概念"></a>1.top chunk概念</h4><ul>
<li>当我们分配一块堆内存时，top chunk是出于地址的最高处的，其前面就是我们所申请的chunk</li>
</ul>
<h4 id="2-top-chunk的合并操作"><a href="#2-top-chunk的合并操作" class="headerlink" title="2.top chunk的合并操作"></a>2.top chunk的合并操作</h4><ul>
<li>如果top chunk前面的chunk不是fast chunk并且处于空闲，那么top chunk就会合并这个chunk</li>
<li>如果top chunk前面的chunk是fast chunk，不论是否空闲，top chunk都不会合并这个chunk</li>
</ul>
<h4 id="3-演示-1"><a href="#3-演示-1" class="headerlink" title="3.演示"></a>3.演示</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>); <span class="comment">//只为了程序打断点，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>断点 堆信息</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215194907019.png" alt="image-20201215194907019"></p>
<p>释放p2 可以看到p2是fastbins 未被合并</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215194956787.png" alt="image-20201215194956787"></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>); <span class="comment">//只为了程序打断点，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>断点</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215195122071.png" alt="image-20201215195122071"></p>
<p>释放p2 可以看到p2被合并了</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215195147425.png" alt="image-20201215195147425"></p>
</blockquote>
<h4 id="4-如何防止top-chunk的合并"><a href="#4-如何防止top-chunk的合并" class="headerlink" title="4.如何防止top chunk的合并"></a>4.如何防止top chunk的合并</h4><ul>
<li>只需要在free掉的chunk后面继续申请一个chunk，这样top chunk就不会合并之前的chunk</li>
</ul>
<h3 id="0x12-chunk的malloc、free"><a href="#0x12-chunk的malloc、free" class="headerlink" title="0x12 chunk的malloc、free"></a>0x12 chunk的malloc、free</h3><h4 id="1-malloc的机制"><a href="#1-malloc的机制" class="headerlink" title="1.malloc的机制"></a>1.malloc的机制</h4><ul>
<li><strong>如果程序是第一次malloc：</strong>会创建一个很大的“top chunk”</li>
<li><strong>如果程序是第二次及之后malloc：</strong>会去先向bins链表寻找空间，如果没有再去向“top chunk”要空间；如果“top chunk”使用完了再通过glibc重新申请一块新的“top chunk”</li>
</ul>
<h4 id="2-演示"><a href="#2-演示" class="headerlink" title="2.演示"></a>2.演示</h4><p>上面我们已经演示过很多回了 第一次就不演示了 这里主要来看一下第二次的malloc</p>
<p>这里是拿fastbin的例子</p>
<h5 id="恰好分割一整块的free-chunk（fastbin）"><a href="#恰好分割一整块的free-chunk（fastbin）" class="headerlink" title="恰好分割一整块的free chunk（fastbin）"></a><strong>恰好分割一整块的free chunk（fastbin）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    sleep(<span class="number">0</span>); <span class="comment">//只为了程序打断点，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接看free掉p1之后可以看到是进入fastbin了</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215200256907.png" alt="image-20201215200256907"></p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215200306820.png" alt="image-20201215200306820"></p>
<p>我们在来申请p2 可以看见是直接覆盖了p1</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215200355918.png" alt="image-20201215200355918"></p>
</blockquote>
<h5 id="切割一块chunk（fastbin）"><a href="#切割一块chunk（fastbin）" class="headerlink" title="切割一块chunk（fastbin）"></a><strong>切割一块chunk（fastbin）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x20</span>;</span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);    sleep(<span class="number">0</span>); <span class="comment">//只为了程序打断点，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>我们直接看p2分配之后把</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215200826010.png" alt="image-20201215200826010"></p>
<p>这里可以看出它并未用fastbin的chunk 而是从top chunk切割了一部分</p>
</blockquote>
<h5 id="恰好分割一整块的free-chunk（unsorted-bin）"><a href="#恰好分割一整块的free-chunk（unsorted-bin）" class="headerlink" title="恰好分割一整块的free chunk（unsorted bin）"></a><strong>恰好分割一整块的free chunk（unsorted bin）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x200</span>;</span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//为了达到演示效果，防止p被top chunk合并</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> *p3=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>看一下chunk的信息</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215201134939.png" alt="image-20201215201134939"></p>
<p>free p1，将p1放入了unsorted bin中</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215201206634.png" alt="image-20201215201206634"></p>
<p>分配p3 可以看到是直接覆盖p1的地方</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215201235306.png" alt="image-20201215201235306"></p>
</blockquote>
<h5 id="切割一块chunk（unsorted-bin）"><a href="#切割一块chunk（unsorted-bin）" class="headerlink" title="切割一块chunk（unsorted bin）"></a><strong>切割一块chunk（unsorted bin）</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">void</span> *temp=<span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//为了防止p被topchunk合并</span></span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里我们直接看p2分配之后</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215201554898.png" alt="image-20201215201554898"></p>
<p>这里为什么会出现这个情况呢？</p>
<p>其实它是在unsorted bin中切割了一块符合自己大小的chunk 拿出来分配</p>
</blockquote>
<p><strong>分割一块较大的free chunk（unsorted bin）</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">void</span> *temp=<span class="built_in">malloc</span>(<span class="number">0x100</span>); <span class="comment">//为了防止p被topchunk合并</span></span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x300</span>);</span><br><span class="line">    <span class="built_in">free</span>(p2);c</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>根据上面的理论这回就应该去top chunk中切割了 事实也确实如此</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201215202105325.png" alt="image-20201215202105325"></p>
</blockquote>
<p>经过以上演示我们不难得出一下结论</p>
<ol>
<li>只要切割大小正好 它就会从已free的chunk中寻找</li>
<li>关于fastbin 和 unsorted bin中free chunk分配是不一样的</li>
<li>如果较大 会从top chunk中寻找</li>
</ol>
<h4 id="3-free的机制"><a href="#3-free的机制" class="headerlink" title="3.free的机制"></a>3.free的机制</h4><ul>
<li>①如果free的chunk的大小在0x20~0x80之间（fastbin的范围），那么该chunk直接放到fast bin上</li>
<li>②如果free的chunk的大小大于0x80（大于fast bin的范围），此时不会直接放到small bin或者large bin上面。而是放到unsorted bin上面</li>
</ul>
<h3 id="0x13-malloc-consolidate"><a href="#0x13-malloc-consolidate" class="headerlink" title="0x13 malloc_consolidate"></a>0x13 malloc_consolidate</h3><p><strong>这个主要是解决unsorted bin中的碎片化，整合成新的bin，也就是放入small bin或large bin中</strong></p>
<h4 id="1-consolidate的定义"><a href="#1-consolidate的定义" class="headerlink" title="1.consolidate的定义"></a>1.consolidate的定义</h4><ul>
<li>我们知道大于0x80的chunk被释放之后就放到了unsortedbin上面去，但是unsortedbin是一个未分类的bin，上面的chunk也处于未分类的状态。但是这些chunk需要在特定的条件下被整理然后放入到smallbins或者largebins中</li>
<li>这个整理的过程被称为unsortedbin的“consolidate”，但是“consolidate”是要在特定的条件下才会发生的，并且与malloc紧密相关</li>
</ul>
<h4 id="2-触发场景"><a href="#2-触发场景" class="headerlink" title="2.触发场景"></a>2.触发场景</h4><ul>
<li>当我们malloc一个chunk，这个chunk的大小大于smallbin的范围，在unsortedbin中寻找可用的freechunk使用时，会触发malloc_conlolidate</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/20190810155737453.png" alt="img"></p>
<ul>
<li>malloc时如果bin链中没有可以使用的freechunk，并且去切割topchunk，发现topchunk也不够用，此时回去再去调用malloc_consolidate进行一次整理</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/20190810155901661.png" alt="img"></p>
<ul>
<li>发现unsortedbin中有大的freechunk可以切割给malloc使用时，切割unsortedbin，产生last remainder的时候会consolidate</li>
</ul>
<p><strong>着重强调，1和2都会去寻找fastbin中的free chunk</strong></p>
<h4 id="3-具体分析"><a href="#3-具体分析" class="headerlink" title="3.具体分析"></a>3.具体分析</h4><p><strong>当我们malloc一个大小大于smallbin的chunk时：</strong></p>
<ul>
<li><p><strong>第一步：</strong>将fastbins中的chunk都整理到unsortedbin中，整理的过程中如果有物理相邻且空闲的fastchunk就合并，如果fastchunk与topchunk相邻，那么fastchunk就与topchunk合并（这个过程发生在_int_malloc函数调用的malloc_consolidate函数中）</p>
</li>
<li><p><strong>第二步：</strong>malloc去检查unsortedbin中是否有与自己malloc大小相对应的chunk可以使用，如果有与自己malloc大小相对应的chunk可以使用就直接使用；如果没有那么就去判断unsortedbin中是否有可以用来切割的大chunk可以使用，如果可以切割，就切割大的chunk使用，然后产生last remainder（这个过程发生在_int_malloc函数的for循环中）</p>
</li>
<li><strong>第三步：</strong>如果没有可以切割的大chunk可以使用，此时就将unsortedbin上的chunk放入到对应的bins链上</li>
<li><strong>第四步：</strong>malloc从第一次分配的大堆块上面找空间来使用</li>
</ul>
<h4 id="4-演示一"><a href="#4-演示一" class="headerlink" title="4.演示一"></a>4.演示一</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>); <span class="comment">//只为了程序打断点使用，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>打断点 看堆信息</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216141039796.png" alt="image-20201216141039796"></p>
<p>释放p1 看到进入fastbin中</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216141113312.png" alt="image-20201216141113312"></p>
<p>分配p2 可以看到我们p1好像是被覆盖了  我们具体来说一下这个过程</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216141143610.png" alt="image-20201216141143610"></p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216141159043.png" alt="image-20201216141159043"></p>
<p>当分配比small bin大的chunk时，我们就会触发consolidate，</p>
<ol>
<li>我们知道fastchunk是不会合并的 所以它们这时就会进入unsortedbin中</li>
<li>然后malloc去切割unsortedbin中的这个freechunk，发现不能够切割，于是就放入smallbin中，放入smallbin中之后便成为smallchunk了，就可以与topchunk合并了</li>
<li>合并之后malloc从topchunk中申请一个堆块</li>
</ol>
</blockquote>
<h4 id="5-演示二"><a href="#5-演示二" class="headerlink" title="5.演示二"></a>5.演示二</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *p=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="keyword">void</span> *p1=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    sleep(<span class="number">0</span>); <span class="comment">//只为了程序打断点使用，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line"> 	<span class="built_in">free</span>(p1);</span><br><span class="line">    <span class="keyword">void</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x500</span>);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>释放p1和p</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216142837517.png" alt="image-20201216142837517"></p>
<p>下面我们猜想会发送什么?</p>
<p>由于分配chunk较大 所以我们会触发consolidate 这时两个fastchunk就会进入unsortedbin中 根据上面规则 它下一步就会进入small bins</p>
<p>又因为和top chunk相邻 所以top chunk会合并 </p>
<p>直观感觉就是我们覆盖了之前的chunk</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216143203315.png" alt="image-20201216143203315"></p>
</blockquote>
<h3 id="0x14-last-remainder"><a href="#0x14-last-remainder" class="headerlink" title="0x14 last remainder"></a>0x14 last remainder</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h4><ul>
<li>如果在bins链中存在freechunk时，当我们去malloc的时候，malloc的请求大小比freechunk的大小小，那么arena就会切割这个freechunk给malloc使用，那么切割之后剩余的chunk就<strong>被称为“last remainder”</strong></li>
<li>当产生last remainder之后，表示arena的<strong>malloc_state结构体中的last_remainder成员</strong>指针就会<strong>被初始化</strong>，并且指向这个last remainder</li>
</ul>
<h4 id="2-产生场景"><a href="#2-产生场景" class="headerlink" title="2.产生场景"></a>2.产生场景</h4><ul>
<li>malloc的时候，不论malloc的大小，首先会去检查每个bins链（出去fastbins链）是否有与malloc相等大小的freechunk，如果没有就去检查bins链中是否有大的freechunk可以切割，如果切割，那么就切割大的freechunk，那么切割之后的chunk成为last remainder，并且last remainder会被放入到unsortedbin中</li>
</ul>
<blockquote>
<p><strong>切割unsortedbin中的大chunk时：</strong></p>
<p>当unsortedbin有对应的freechunk可以给malloc切割使用时，unsortedbin会发生以下步骤：</p>
<ul>
<li>①先将这些freechunk放置到对应大小的bins链上（放入smallbin或largebin）</li>
<li>②放置到对应的bins链上之后，切割此freechunk</li>
<li>③切割之后会产生last remainder，再将last remainder放到unsortedbin上</li>
</ul>
<p><strong>例如：</strong></p>
<ul>
<li>此时，unsortedbin有两个0x800的freechunk</li>
<li>此时申请一个0x600的chunk</li>
<li>那么unsortedbin会先consolidate，把两个0x800的freechunk先移动到largebin中</li>
<li>然后再切割largebin的freechunk，将切割后余留下的0x200放入unsortedbin</li>
</ul>
<p><strong>切割smallbins、largebins中的大chunk时：</strong></p>
<ul>
<li>①切割smallbins或者largebins中的大freechunk，产生last remainder</li>
<li>②将last remainder放入到unsortedbin中</li>
</ul>
</blockquote>
<h4 id="3-last-remainder的consolidate"><a href="#3-last-remainder的consolidate" class="headerlink" title="3.last remainder的consolidate"></a>3.last remainder的consolidate</h4><p>当我们切割一个bins链中的大chunk时产生last reminader时，会发生consolidate，<strong>但是此种consolidate不会去整理fastbins中的freechunk（重点）</strong></p>
<h4 id="4-演示一-1"><a href="#4-演示一-1" class="headerlink" title="4.演示一"></a>4.演示一</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="number">0x120</span>;</span><br><span class="line">    <span class="keyword">void</span> *p = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *junk = <span class="built_in">malloc</span>(<span class="built_in">size</span>);  <span class="comment">//放置释放p和q之后，p和q发生合并</span></span><br><span class="line">    <span class="keyword">void</span> *q = <span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">void</span> *r = <span class="built_in">malloc</span>(<span class="built_in">size</span>);   <span class="comment">//放置释放q之后，q和topchunk发生合并</span></span><br><span class="line">	</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"p:0x%x\n"</span>,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"q:0x%x\n"</span>,q);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"r:0x%x\n"</span>,r);</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">strcpy</span>(p,<span class="string">"aaaaaaaabbbbbbbb"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(q,<span class="string">"ccccccccdddddddd"</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(r,<span class="string">"eeeeeeeeffffffff"</span>);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为了打断点使用，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">	</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(q);</span><br><span class="line">	</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>断点</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216151435089.png" alt="image-20201216151435089"></p>
<p>释放p和q</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216151556927.png" alt="image-20201216151556927"></p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216151633713.png" alt="image-20201216151633713"></p>
<p>分配0x90  </p>
<ul>
<li>首先两个unsortedbin chunk中可以分割到0x90那么就会consolidate 将其全部放入smallbins中</li>
<li>之后分割其中一部分 并将剩余的放入lastremainder</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216151705158.png" alt="image-20201216151705158"></p>
</blockquote>
<h4 id="5-演示二-1"><a href="#5-演示二-1" class="headerlink" title="5.演示二"></a>5.演示二</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x30</span>;</span><br><span class="line">    <span class="keyword">int</span> size2=<span class="number">0x200</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(size2);</span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//防止p2和p3都被释放之后，p2和p3发生合并</span></span><br><span class="line">    <span class="keyword">int</span> *p3=<span class="built_in">malloc</span>(size2);</span><br><span class="line">    <span class="keyword">int</span> *temp2=<span class="built_in">malloc</span>(<span class="built_in">size</span>); <span class="comment">//防止p3被释放之后与topchunk合并</span></span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//只为打断点使用</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line">    <span class="built_in">free</span>(p3);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接看释放p1 p2 p3</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216155717972.png" alt="image-20201216155717972"></p>
<p>这里继续想一下下一步会发生什么？</p>
<ul>
<li>分配大小0x100可以分配 那么就直接触发consolidate说明smallbin中就会有free chunk</li>
<li>lastremainder会放入unsortedbin中，此外fastfreechunk不会合并</li>
<li>那么我们就得到了</li>
</ul>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216160152597.png" alt="image-20201216160152597"></p>
</blockquote>
<h4 id="6-演示三"><a href="#6-演示三" class="headerlink" title="6.演示三"></a>6.演示三</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(<span class="built_in">size</span>);  <span class="comment">//防止p1被释放之后与topchunk合并</span></span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//为了程序打断点使用，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x700</span>);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>直接看p1释放后</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216160410739.png" alt="image-20201216160410739"></p>
<p>之后会分配0x700说明要分配较大的chunk 此时会被整理到smallbins中</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216160827250.png" alt="image-20201216160827250"></p>
<p>继续分配0x200 lastremainder会进入unsortedbin中</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216160910272.png" alt="image-20201216160910272"></p>
</blockquote>
<h4 id="7-演示四"><a href="#7-演示四" class="headerlink" title="7.演示四"></a>7.演示四</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;malloc.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>=<span class="number">0x300</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> *temp=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">    <span class="keyword">int</span> *p1=<span class="built_in">malloc</span>(<span class="built_in">size</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//防止p1释放并consolidate到smallbins中之后，再释放p2导致p1和p2合并，合并之后又被放入unsortedbin中</span></span><br><span class="line">    <span class="keyword">int</span> *temp2=<span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> *p2=<span class="built_in">malloc</span>(<span class="number">0x100</span>); </span><br><span class="line">    <span class="keyword">int</span> *p3=<span class="built_in">malloc</span>(<span class="built_in">size</span>);<span class="comment">//防止p2被释放之后与topchunk合并</span></span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>);  <span class="comment">//为了程序打断点使用，无其他作用</span></span><br><span class="line">    <span class="built_in">free</span>(p1);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x700</span>);</span><br><span class="line">    </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="built_in">free</span>(p2);</span><br><span class="line"> </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>先看堆信息</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216164710877.png" alt="image-20201216164710877"></p>
<p>释放p1</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216164747866.png" alt="image-20201216164747866"></p>
<p>分配0x700 由于unsorted bin中的chunk不够 所以直接从top chunk中分割</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216164913709.png" alt="image-20201216164913709"></p>
<p>free tmp和p2</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216165109899.png" alt="image-20201216165109899"></p>
<p>重点来看最后一步 这里，malloc(0x200)，此时malloc会切割smallbins中的p1，并产生last remainder（0x602250），并把last remainder放入到unsortedbin中。由于切割chunk并产生last remainder会发生consolidate，所以unsortedbin中的p2从unsortedbin中整理到smallbins中（由于此种情况的consolidate不会整理fastbins中的chunk，所以fastbins中的chunk仍然在fastbins中）</p>
<p><img src="/2020/12/15/%E5%A0%86/image-20201216165224983.png" alt="image-20201216165224983"></p>
</blockquote>

    
  </div>

</article>


   

   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2020/12/09/SQL%E6%B3%A8%E5%85%A5/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2020/12/16/plt%E8%A1%A8%E5%92%8Cgot%E8%A1%A8/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">Close</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              Blog
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/tag/"
              rel="noopener noreferrer"
              target="_self"
              >
              Tag
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="ROUND_RECT"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              About
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//cdn.jsdelivr.net/npm/valine@latest/dist/Valine.min.js"></script>
    <div id="comment" class="vcomment" ></div>
    <script>
        var notify = 'true' == true ? true : false;
        var verify = 'true' == true ? true : false;
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
            return GUEST_INFO.indexOf(item) > -1
        });
        guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
        window.valine = new Valine({
            el: '.vcomment',
            notify: notify,
            verify: verify,
            appId: "KLWvKGPeSIyoEo4k6j3v37wy-gzGzoHsz",
            appKey: "FL93w3BBbF9lxiR8X1HI58En",
            avatar:'wavatar',
            placeholder: "Just go go",
            guest_info:guest_info,
            pageSize:'6'
        });
    </script>
  
    

  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
